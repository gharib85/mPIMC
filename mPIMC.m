(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["mPIMC`"];
startingPositions::usage="startingPositions[numparticles,numslices,samplerange,sampledelta,dimensionality]
numparticles - the number of particles in the system
numslices - the number of slices/beads per particle
samplerange - the position range over which to look for local minima to start particles in
sampledelta - the position sampling size over which minima are sought
dimensionality - the dimension of the system
RETURN - a {numparticles,numslices,dimensionality} vector of the starting positions for particles, which should be perturbed using pathInitialise

startingPositions looks for approximate local minima of the external potential, returning a vector of where particles should start out";
startingPositions::argnum="startingPositions was called with `1` arguments.  It expected 5.";
pathInitialise::usage="pathInitialise[numparticles,numslices,\[Lambda],\[Tau],dimensionality]
numparticles - the number of particles in the system
numslices - the number of slices/beads per particle
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - the dimension of the system
RETURN - a {numparticles,numslices,dimensionality} vector of positions randomly distributed around the origin, drawn from a flat distribution of the width of the thermal wavelength

pathInitialise slightly randomises initial starting positions over the order of the thermal wavelength";
pathInitialise::argnum="pathInitialise was called with `1` arguments.  It expected 5.";
vprime::usage="vprime[path,particle,bead]
path - list of all particle and bead positions at a given time step
particle - individual particle for which to calculate vprime
bead - individual bead of that particle for which to calculate vripime
RETURN - a {dimensionality} vector of the derivative of the potential at the position of the selected particle

vprime calculates the first derivative of the external potential and interparticle potential at the position of a given particle";
vprime::argnum="vprime was called with `1` arguments.  It expected 3.";
springkinetic::usage="springkinetic[post1,post2,\[Lambda],\[Tau]]
post1 - position of first particle bead
post2 - position of second particle bead
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
RETURN - a real number expressing the kinetic energy from the 'spring' between two beads

springkinetic calculates the contribution to the kinetic energy from a single pair of adjacent beads with given positions.  Note, almost always better to use springkineticC";
springkinetic::argnum="springkinetic was called with `1` arguments.  It expected 4.";
springkineticC::usage="springkineticC[post1,post2,\[Lambda],\[Tau]]
post1 - position of first particle bead
post2 - position of second particle bead
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
RETURN - a real number expressing the kinetic energy from the 'spring' between two beads

springkineticC calculates the contribution to the kinetic energy from a single pair of adjacent beads with given positions";
springkineticC::argnum="springkineticC was called with `1` arguments.  It expected 4.";
place::usage="place[length,placed]
length - the length of the list
placed - the position which may sit within a list of length 'length', or may sit within 'length' either side of it
RETURN - an integer expressing a new value of placed

place rounds placed to sit within the range [1,length], useful if labels have been cycled";
place::argnum="place was called with `1` arguments.  It expected 2.";
normalVariate::usage="normalVariate[\[Mu],\[Sigma],dimensionality]
\[Mu] - mean value to draw values around (usually 0)
\[Sigma] - standard deviation of samples to draw
dimensionality - dimension of the system
RETURN - a {dimensionality} position vector of random values drawn from a normal distribution

normalVariate gives a random vector drawn from a normal distribution with mean \[Mu] and standard deviation \[Sigma]";
normalVariate::argnum="normalVariate was called with `1` arguments.  It expected 3.";
singleBeadDisplace::usage="singleBeadDisplace[path,\[Lambda],\[Tau],dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - dimension of the system
RETURN - {move accepted (True/False),new path}

singleBeadDisplace randomly selects one particle, relabels its beads, then moves the second bead of this particle by random vector.  If move is accepted (acceptprob>randomreal), replace position of this bead with new position";
singleBeadDisplace::argnum="singleBeadDisplace was called with `1` arguments.  It expected 4.";
singleElectronDisplace::usage="singleElectronDisplace[path,\[Lambda],\[Tau],dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - dimension of the system
RETURN - {move accepted (True/False),new path}

singleElectronDisplace randomly selects one particle, shifts all the beads of it by a random vector.  If move is accepted (acceptprob>randomreal), replace electron positions with new positions";
singleElectronDisplace::argnum="singleElectronDisplace was called with `1` arguments.  It expected 4.";
bisectionMover::usage="bisectionMover[path,places,\[Lambda],\[Tau],dimensionality]
path - list of all bead positions at a given time step for a given particle (note unusual definition)
places - a list of three bead numbers, of which the second corresponds to a bead to be moved
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - dimension of the system
RETURN - a {dimensionality} position vector for the new position of the second bead in 'places'

bisectionMover is a function to bisect given bead positions to find a new bead position, and then offset from it a random amount drawn from a normal distribution of order the thermal wavelength.  Note, almost always better to use bisectionMoverC";
bisectionMover::argnum="bisectionMover was called with `1` arguments.  It expected 5.";
bisectionMoverC::usage="bisectionMoverC[path,places,\[Lambda],\[Tau],dimensionality]
path - list of all bead positions at a given time step for a given particle (note unusual definition)
places - a list of three bead numbers, of which the second corresponds to a bead to be moved
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - dimension of the system
RETURN - a {dimensionality} position vector for the new position of the second bead in 'places'

bisectionMoverC is a function to bisect given bead positions to find a new bead position, and then offset from it a random amount drawn from a normal distribution of order the thermal wavelength";
bisectionMoverC::argnum="bisectionMoverC was called with `1` arguments.  It expected 5.";
bisectionMove::usage="bisectionMove[path,\[Lambda],\[Tau],dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
dimensionality - dimension of the system
RETURN - {move accepted (True/False),new path}

bisectionMove randomly selects one particle, relabls its beads, then implements a bisection algorithm on its beads.  In this algorithm, for each step the middle bead of the subsections of the arrays is moved by a random distance set to sample the kinetic energy density matrix.  Then, at each step, the potential energy is compared with old move, and accepted or not. DEPRECATED";
bisectionMove::argnum="bisectionMove was called with `1` arguments.  It expected 4.";
bisectionMoveStatistics::usage="bisectionMoveStatistics[path,\[Lambda],\[Tau],joined,maxcyclelength,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
joined - an association of each particle, showing which particle is joined before it
maxcyclelength - the maximum number of particles to attempt to permute labels of in a single move
dimensionality - dimension of the system
RETURN - {move accepted (True/False),new path}

bisectionMoveStatistics randomly selects one particle, relabls its beads, then implements a bisection algorithm on its beads.  In this algorithm, for each step the middle bead of the subsections of the arrays is moved by a random distance set to sample the kinetic energy density matrix.  Then, at each step, the potential energy is compared with old move, and accepted or not.  In addition, chains of beads can join or split apart (implementing bosonic statistics), handled by the association 'joined'";
bisectionMoveStatistics::argnum="bisectionMoveStatistics was called with `1` arguments.  It expected 6.";
permutationSampler::usage="permutationSampler[path,\[Lambda],\[Tau],joined,cyclelength,beads]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
joined - an association of each particle, showing which particle is joined before it
cyclelength - the number of particles whose labels are being permuted
beads - the number of beads/slices per uncorrelated particle
RETURN - an association of the newly joined particle labels

permutationSampler samples permutations of the different particle labels, and returns a new joined association if energetically favourable";
permutationSampler::argnum="permutationSampler was called with `1` arguments.  It expected 6.";
potentialAction1bead::usage="potentialAction1bead[path,\[Lambda],\[Tau],particle,bead]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
particle - the particular particle to calculate the contribution to the potential action for
bead - the particular bead of that particle to calculate the contribution to the potential action for
RETURN - a real number expressing the potential action of that particle bead in all potentials

potentialAction1bead gives the potential action contribution of each particle to the action, symmetrized and in the primitive approximation. DEPRECATED";
potentialAction1bead::argnum="potentialAction1bead was called with `1` arguments.  It expected 5.";
potentialAction1beadStatistics::usage="potentialAction1beadStatistics[path,\[Lambda],\[Tau],particle,bead,joined]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
particle - the particular particle to calculate the contribution to the potential action for
bead - the particular bead of that particle to calculate the contribution to the potential action for
joined - an association of each particle, showing which particle is joined before it
RETURN - a real number expressing the potential action of that particle bead in all potentials

potentialAction1beadStatistics gives the potential action contribution of each particle to the action, symmetrized, including the possibility of permutations, and in the primitive approximation. Note: generally better to use potentialAction1beadStatisticsC";
potentialAction1beadStatistics::argnum="potentialAction1beadStatistics was called with `1` arguments.  It expected 6.";
potentialAction1beadStatisticsC::usage="potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],particle,bead,joined]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
particle - the particular particle to calculate the contribution to the potential action for
bead - the particular bead of that particle to calculate the contribution to the potential action for
joined - an array showing which particle is joined before the corresponding particle (note unusual definition: Values@joined)
RETURN - a real number expressing the potential action of that particle bead in all potentials

potentialAction1beadStatisticsC gives the potential action contribution of each particle to the action, symmetrized, including the possibility of permutations, and in the primitive approximation";
potentialAction1beadStatisticsC::argnum="potentialAction1beadStatisticsC was called with `1` arguments.  It expected 6.";
kineticAction1bead::usage="kineticAction1bead[path,\[Lambda],\[Tau],particle,bead]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
particle - the particular particle to calculate the contribution to the potential action for
bead - the particular bead of that particle to calculate the contribution to the kinetic action for
RETURN - a real number expressing the kinetic action of that particle bead

kineticAction1bead gives the kinetic action contribution of each particle bead to the action";
kineticAction1bead::argnum="kineticAction1bead was called with `1` arguments.  It expected 5.";
kineticAction2bead::usage="kineticAction2bead[path,\[Lambda],\[Tau],particle,bead1,bead2]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
particle - the particular particle to calculate the contribution to the potential action for
bead1 - one particular bead of that particle to calculate the contribution to the kinetic action for
bead2 - another particular bead of that particle to calculate the contribution to the kinetic action for
RETURN - a real number expressing the kinetic action of two beads

kineticAction2bead gives the kinetic action contribution of a pair of particle beads to the action";
kineticAction2bead::argnum="kineticAction2bead was called with `1` arguments.  It expected 6.";
kineticActionOffset::usage="kineticActionOffset[\[Lambda],\[Tau],numparticles,numslices,dimensionality]
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - the number of particles in the system
numslices - the number of slices/beads for each particle
dimensionality - the dimension of the system
RETURN - a real number giving the classical contribution to the kinetic energy

kineticActionOffset calculates the semi-classical kinetic energy of a particle for use in virial-style estimators";
kineticActionOffset::argnum="kineticActionOffset was called with `1` arguments.  It expected 5.";
virialTotalEnergyEstimator::usage="virialTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

virialTotalEnergyEstimator gives an estimator for the total energy, calculated in the virial approximation. DEPRECATED";
virialTotalEnergyEstimator::argnum="virialTotalEnergyEstimator was called with `1` arguments.  It expected 6.";
virialTotalEnergySquaredEstimator::usage="virialTotalEnergySquaredEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total squared energy

virialTotalEnergySquaredEstimator gives an estimator for the total energy squared, calculated in the virial approximation. DEPRECATED";
virialTotalEnergySquaredEstimator::argnum="virialTotalEnergySquaredEstimator was called with `1` arguments.  It expected 6.";
virialTotalEnergyEstimatorStatistics::usage="virialTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

virialTotalEnergyEstimatorStatistics gives an estimator for the total energy, calculated in the virial approximation";
virialTotalEnergyEstimatorStatistics::argnum="virialTotalEnergyEstimatorStatistics was called with `1` arguments.  It expected 7.";
virialTotalEnergySquaredEstimatorStatistics::usage="virialTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total squared energy

virialTotalEnergySquaredEstimatorStatistics gives an estimator for the total energy squared, calculated in the virial approximation";
virialTotalEnergySquaredEstimatorStatistics::argnum="virialTotalEnergySquaredEstimatorStatistics was called with `1` arguments.  It expected 7.";
thermTotalEnergyEstimator::usage="thermTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

thermTotalEnergyEstimator gives an estimator for the total energy, calculated in the thermodynamic approximation. DEPRECATED";
thermTotalEnergyEstimator::argnum="thermTotalEnergyEstimator was called with `1` arguments.  It expected 6.";
thermTotalEnergySquaredEstimator::usage="thermTotalEnergySquaredEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total squared energy

thermTotalEnergySquaredEstimator gives an estimator for the total energy squared, calculated in the thermodynamic approximation. DEPRECATED";
thermTotalEnergySquaredEstimator::argnum="thermTotalEnergySquaredEstimator was called with `1` arguments.  It expected 6.";
thermTotalEnergyEstimatorStatistics::usage="thermTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

thermTotalEnergyEstimatorStatistics gives an estimator for the total energy, calculated in the thermodynamic approximation";
thermTotalEnergyEstimatorStatistics::argnum="thermTotalEnergyEstimatorStatistics was called with `1` arguments.  It expected 7.";
thermTotalEnergySquaredEstimatorStatistics::usage="thermTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total squared energy

thermTotalEnergySquaredEstimatorStatistics gives an estimator for the total energy squared, calculated in the thermodynamic approximation";
thermTotalEnergySquaredEstimatorStatistics::argnum="thermTotalEnergySquaredEstimatorStatistics was called with `1` arguments.  It expected 7.";
fullVirialTotalEnergyEstimatorStatistics::usage="fullVirialTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

fullVirialTotalEnergyEstimatorStatistics gives an estimator for the total energy, calculated in the virial approximation";
fullVirialTotalEnergyEstimatorStatistics::argnum="fullVirialTotalEnergyEstimatorStatistics was called with `1` arguments.  It expected 7.";
fullVirialTotalEnergySquaredEstimatorStatistics::usage="fullVirialTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total squared energy

fullVirialTotalEnergySquaredEstimatorStatistics gives an estimator for the total energy squared, calculated in the virial approximation";
fullVirialTotalEnergySquaredEstimatorStatistics::argnum="fullVirialTotalEnergySquaredEstimatorStatistics was called with `1` arguments.  It expected 7.";
heinzeTotalEnergyEstimator::usage="heinzeTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the total energy

heinzeTotalEnergyEstimator gives an estimator for the total energy, calculated according to the Heinze procedure, see http://oops.uni-oldenburg.de/274/1/304.pdf, p. 26.  Note: factor of 2 is a fudge, not properly physically motivated";
heinzeTotalEnergyEstimator::argnum="heinzeTotalEnergyEstimator was called with `1` arguments.  It expected 6.";
heinzeKineticEnergyEstimator::usage="heinzeKineticEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the kinetic energy

heinzeKineticEnergyEstimator gives an estimator for the kinetic energy, calculated according to the Heinze procedure, see http://oops.uni-oldenburg.de/274/1/304.pdf, p. 26";
heinzeKineticEnergyEstimator::argnum="heinzeKineticEnergyEstimator was called with `1` arguments.  It expected 6.";
heinzePotentialEnergyEstimator::usage="heinzePotentialEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]
path - list of all particle and bead positions at a given time step
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - number of particles in the system
numslices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a real number giving an estimator for the potential energy

heinzePotentialEnergyEstimator gives an estimator for the potential energy, calculated according to the Heinze procedure, see http://oops.uni-oldenburg.de/274/1/304.pdf, p. 26";
heinzePotentialEnergyEstimator::argnum="heinzePotentialEnergyEstimator was called with `1` arguments.  It expected 6.";
heinzePairDist::usage="heinzePairDist[path,numparticles,numslices]
path - list of all particle and bead positions at a given time step
numparticles - number of particles in the system
numslices - number of slices/beads per particle
RETURN - an array of inter-particle distance vectors

heinzePairDist gives an approximation to the density-density correlation function, calculated at each time step, for use in calculating the total energy";
heinzePairDist::argnum="heinzePairDist was called with `1` arguments.  It expected 3.";
heinzeParticleDist::usage="heinzeParticleDist[path,numparticles,numslices]
path - list of all particle and bead positions at a given time step
numparticles - number of particles in the system
numslices - number of slices/beads per particle
RETURN - an array of position vectors

heinzeParticleDist gives an approximation to the density, calculated at each time step, for use in calculating the total energy";
heinzeParticleDist::argnum="heinzeParticleDist was called with `1` arguments.  It expected 3.";
potentialPlot::usage="potentialPlot[path,dimensionality]
path - list of all particle and bead positions at a given time step
dimensionality - the dimension of the system
RETURN - a plot of the external potential

potentialPlot creates a plot of the external potential, given a realisation of particle positions";
potentialPlot::argnum="potentialPlot was called with `1` arguments.  It expected 2.";
energyPlot::usage="energyPlot[energyVirial,energyFullVirial,energyTherm,energyHeinze,energysaverarrayvirial,energysaverarrayfullvirial,energysaverarraytherm,energysaverarrayheinze,invvarvirial,invvarfullvirial,invvartherm,invvarheinze,equilibrationsteps,numsteps,harmonictrap,\[Omega],\[Tau],slices,dimensionality]
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
energysaverarrayvirial - an array of energies calculated in the virial approximation
energysaverarrayfullvirial - an array of energies calculated in the full virial approximation
energysaverarraytherm - an array of energies calculated in the thermodynamic approximation
energysaverarrayheinze - an array of energies calculated using the Heinze procedure
invvarvirial - an array of inverse variances of the energy calculated in the virial approximation
invvarfullvirial - an array of inverse variances of the energy calculated in the full virial approximation
invvartherm - an array of inverse variances of the energy calculated in the thermodynamic approximation
invvarheinze - an array of inverse variances of the energy calculated using the Heinze procedure
equilibrationsteps - the number of equilibration steps taken before calculating estimators
numsteps - the total number of time steps used
harmonictrap - whether to calculate properties in a corresponding harmonic trap
\[Omega] - corresponding harmonic trap frequency
\[Tau] - the time step, also a measure of inverse temperature
slices - number of slices/beads per particle
dimensionality - the dimension of the system
RETURN - a plot of the energy estimators in the system

energyPlot creates a plot of the energy estimators as a function of step number, showing also the average values and their error bars and analytic approximations if requested";
energyPlot::argnum="energyPlot was called with `1` arguments.  It expected 19.";
pathPlot::usage="pathPlot[path,joined,dimensionality]
path - list of all particle and bead positions at a given time step
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
RETURN - a plot of the position of beads in a given realisation

pathPlot plots paths, including the permutations given in the 'joined' association";
pathPlot::argnum="pathPlot was called with `1` arguments.  It expected 3.";
printEnergyVirial::usage="printEnergyVirial[energysaverarrayvirial,invvarvirial]
energysaverarrayvirial - an array of energies calculated in the virial approximation
invvarvirial - an array of inverse variances of the energy calculated in the virial approximation
RETURN - a string

printEnergyVirial prints the energy expectation value and error in the virial approximation";
printEnergyVirial::argnum="printEnergyVirial was called with `1` arguments.  It expected 2.";
printEnergyFullVirial::usage="printEnergyFullVirial[energysaverarrayvirial,invvarvirial]
energysaverarrayvirial - an array of energies calculated in the full virial approximation
invvarvirial - an array of inverse variances of the energy calculated in the full virial approximation
RETURN - a string

printEnergyFullVirial prints the energy expectation value and error in the full virial approximation";
printEnergyFullVirial::argnum="printEnergyFullVirial was called with `1` arguments.  It expected 2.";
printEnergyTherm::usage="printEnergyTherm[energysaverarraytherm,invvartherm]
energysaverarraytherm - an array of energies calculated in the thermodynamic approximation
invvartherm - an array of inverse variances of the energy calculated in the thermodynamic approximation
RETURN - a string

printEnergyTherm prints the energy expectation value and error in the thermodynamic approximation";
printEnergyTherm::argnum="printEnergyTherm was called with `1` arguments.  It expected 2.";
printEnergyHeinze::usage="printEnergyHeinze[energysaverarrayheinze]
energysaverarrayheinze - an array of energies calculated using the Heinze procedure
RETURN - a string

printEnergyHeinze prints the energy expectation value and error using the Heinze procedure";
printEnergyHeinze::argnum="printEnergyHeinze was called with `1` arguments.  It expected 1.";
autocorrelationPlot::usage="autocorrelationPlot[energyVirial,energyFullVirial,energyTherm,energyHeinze,energysaverarrayvirial,energysaverarrayfullvirial,energysaverarraytherm,energysaverarrayheinze,observablecalc]
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
energysaverarrayvirial - an array of energies calculated in the virial approximation
energysaverarrayfullvirial - an array of energies calculated in the full virial approximation
energysaverarraytherm - an array of energies calculated in the thermodynamic approximation
energysaverarrayheinze - an array of energies calculated using the Heinze procedure
observablecalc - how many time steps between calculating expectation values
RETURN - a plot of the autocorrelation in different energy estimators

autocorrelationPlot creates a plot of the autocorrelation in the different estimators of the energy as a function of step number";
autocorrelationPlot::argnum="autocorrelationPlot was called with `1` arguments.  It expected 9.";
exactHarmonicTrapEnergies::usage="exactHarmonicTrapEnergies[maxval,\[Tau],slices,\[Omega],dimensionality]
maxval - the maximum principal quantum number to use
\[Tau] - the time step, also a measure of inverse temperature
slices - number of slices/beads per particle
\[Omega] - harmonic trap frequency
dimensionality - the dimension of the system
RETURN - a real number that gives the energy of a particle in an harmonic trap

exactHarmonicTrapEnergies gives a numerically exact (as maxval->\[Infinity]) expression for the energy of a single particle in an harmonic trap, for comparison with calculated results";
exactHarmonicTrapEnergies::argnum="exactHarmonicTrapEnergies was called with `1` arguments.  It expected 5.";
exactHarmonicTrapWfns::usage="exactHarmonicTrapWfns[maxval,\[Tau],slices,\[Omega],dimensionality]
maxval - the maximum principal quantum number to use
\[Tau] - the time step, also a measure of inverse temperature
slices - number of slices/beads per particle
\[Omega] - harmonic trap frequency
dimensionality - the dimension of the system
RETURN - a 1D function corresponding to the x-position of a particle in an harmonic trap

exactHarmonicTrapWfns gives a numerically exact (as maxval->\[Infinity]) expression for the x-position of a single particle in an harmonic trap, for comparison with calculated results";
exactHarmonicTrapWfns::argnum="exactHarmonicTrapWfns was called with `1` arguments.  It expected 5.";
energyArrayMaker::usage="energyArrayMaker[energyassoc,energysquaredassoc]
energyassoc - an association of energies
energysquaredassoc - an association of squared energies
RETURN - an array of two arrays, the energy and inverse variance of the energy

energyArrayMaker takes associations of energies and squared energies, and returns arrays of the energy and the inverse variance, for weighting purposes";
energyArrayMaker::argnum="energyArrayMaker was called with `1` arguments.  It expected 2.";
energyAssocMaker::usage="energyAssocMaker[step,numsteps,\[Lambda],\[Tau],numparticles,numslices,path,dimensionality,type]
step - the time step number
numsteps - the total number of time steps used
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - the number of particles in the system
numslices - the number of slices/beads per particle
path - list of all particle and bead positions at a given time step
dimensionality - the dimension of the system
type - type of energy estimator desired
RETURN - pairs of {{relative step,energy estimator},{relative step,squared energy estimator}} arrays

energyAssocMaker calculates the energy and squared energy in the approximation given by 'type'.  Currently supported versions are 'virial', 'therm', 'heinze'. DEPRECATED";
energyAssocMaker::argnum="energyAssocMaker was called with `1` arguments.  It expected 9.";
energyAssocMakerStatistics::usage="energyAssocMakerStatistics[step,numsteps,\[Lambda],\[Tau],numparticles,numslices,path,joined,dimensionality,type]
step - the time step number
numsteps - the total number of time steps used
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
numparticles - the number of particles in the system
numslices - the number of slices/beads per particle
path - list of all particle and bead positions at a given time step
joined - an association of each particle, showing which particle is joined before it
dimensionality - the dimension of the system
type - type of energy estimator desired
RETURN - pairs of {{relative step,energy estimator},{relative step,squared energy estimator}} arrays

energyAssocMakerStatistics calculates the energy and squared energy in the approximation given by 'type'.  Currently supported versions are 'virial', 'fullvirial', 'therm', 'heinze'";
energyAssocMakerStatistics::argnum="energyAssocMakerStatistics was called with `1` arguments.  It expected 10.";
energyMaker::usage="energyMaker[calculateEnergy,energyTherm,energyVirial,energyFullVirial,energyHeinze,harmonictrap,energysaveassoctherm,energysquaredsaveassoctherm,energysaveassocvirial,energysquaredsaveassocvirial,energysaveassocfullvirial,energysquaredsaveassocfullvirial,energysaveassocheinze,energysquaredsaveassocheinze,\[Tau],slices,\[Omega]]
calculateEnergy - whether to calculate the energy expectation value
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
harmonictrap - whether to calculate properties in a corresponding harmonic trap
energysaveassoctherm - association of energies calculated in the thermodynamic approximation
energysquaredsaveassoctherm - association of squared energies calculated in the thermodynamic approximation
energysaveassocvirial - association of energies calculated in the virial approximation
energysquaredsaveassocvirial - association of squared energies calculated in the virial approximation
energysaveassocfullvirial - association of energies calculated in the full virial approximation
energysquaredsaveassocfullvirial - association of squared energies calculated in the full virial approximation
energysaveassocheinze - association of energies calculated using the Heinze procedure
energysquaredsaveassocheinze - association of squared energies calculated using the Heinze procedure
\[Tau] - the time step, also a measure of inverse temperature
slices - the number of slices/beads per particle
\[Omega] - harmonic trap frequency
RETURN - arrays of energies and errors in different approximations

energyMaker takes the associations of energies created at each time step, and converts them into arrays";
energyMaker::argnum="energyMaker was called with `1` arguments.  It expected 17.";
energyPrinter::usage="energyPrinter[calculateEnergy,energyTherm,energyVirial,energyFullVirial,energyHeinze,harmonictrap,energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze,\[Tau],slices,\[Omega],dimensionality]
calculateEnergy - whether to calculate the energy expectation value
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
harmonictrap - whether to calculate properties in a corresponding harmonic trap
energysaverarraytherm - an array of energies calculated in the thermodynamic approximation
invvartherm - an array of inverse variances of the energy calculated in the thermodynamic approximation
energysaverarrayvirial - an array of energies calculated in the virial approximation
invvarvirial - an array of inverse variances of the energy calculated in the virial approximation
energysaverarrayfullvirial - an array of energies calculated in the full virial approximation
invvarfullvirial - an array of inverse variances of the energy calculated in the full virial approximation
energysaverarrayheinze - an array of energies calculated using the Heinze procedure
invvarheinze - an array of inverse variances of the energy calculated using the Heinze procedure
\[Tau] - the time step, also a measure of inverse temperature
slices - the number of slices/beads per particle
\[Omega] - harmonic trap frequency
dimensionality - the dimension of the system
RETURN - Null, prints strings

energyPrinter takes arrays of energies and inverse variances and passes them to routines which print the energy estimators and errors on them";
energyPrinter::argnum="energyPrinter was called with `1` arguments.  It expected 18.";
expectationValueMaker::usage="expectationValueMaker[calculateParticleDensityX,calculatePairCorrelationFunction,numparticles,particleDensityX,vectorPairCorrelationFunction]
calculateParticleDensityX - whether to calculate the single-particle density
calculatePairCorrelationFunction - whether to calculate the pair/density-density correlation function
numparticles - the number of particles in the system
particleDensityX - an association of single-particle positions
vectorPairCorrelationFunction - an association of pairs of particle positions
RETURN - an array of pairs of {density,density-density} arrays

expectationValueMaker takes the associations of expectation values (not the energy) calculated at each time step, and turns them into arrays.  Currently supports density and density-density correlation functions";
expectationValueMaker::argnum="expectationValueMaker was called with `1` arguments.  It expected 5.";
plotMaker::usage="plotMaker[showPaths,calculateEnergy,calculateParticleDensityX,calculatePairCorrelationFunction,allow3DCorrelationPlots,showAutocorrelation,numparticles,path,joined,energyVirial,energyFullVirial,energyTherm,energyHeinze,energysaverarrayvirial,energysaverarrayfullvirial,energysaverarraytherm,energysaverarrayheinze,invvarvirial,invvarfullvirial,invvartherm,invvarheinze,equilibrationsteps,numsteps,harmonictrap,\[Omega],\[Tau],slices,particleDensityXsaverarray,vectorPairCorrelationFunctionsaverarray,binsize,observablecalc,plotPoints,dimensionality]
showPaths - whether to plot a graph of a realisation of particle/bead positions
calculateEnergy - whether to calculate the energy expectation value
calculateParticleDensityX - whether to calculate the single-particle density
calculatePairCorrelationFunction - whether to calculate the pair/density-density correlation function
allow3DCorrelationPlots - whether to make 3D plots of the density and pair correlation function; slower to run if allowed
showAutocorrelation - whether to show the autocorrelation in the energy
numparticles - the number of particles in the system
path - list of all particle and bead positions at a given time step
joined - an association of each particle, showing which particle is joined before it
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
energysaverarrayvirial - an array of energies calculated in the virial approximation
energysaverarrayfullvirial - an array of energies calculated in the full virial approximation
energysaverarraytherm - an array of energies calculated in the thermodynamic approximation
energysaverarrayheinze - an array of energies calculated using the Heinze procedure
invvarvirial - an array of inverse variances of the energy calculated in the virial approximation
invvarfullvirial - an array of inverse variances of the energy calculated in the full virial approximation
invvartherm - an array of inverse variances of the energy calculated in the thermodynamic approximation
invvarheinze - an array of inverse variances of the energy calculated using the Heinze procedure
equilibrationsteps - the number of equilibration steps taken before calculating estimators
numsteps - the total number of time steps used
harmonictrap - whether to calculate properties in a corresponding harmonic trap
\[Omega] - harmonic trap frequency
\[Tau] - the time step, also a measure of inverse temperature
slices - the number of slices/beads per particle
particleDensityXsaverarray - an array of particle positions
vectorPairCorrelationFunctionsaverarray - an array of pairs of particle positions
binsize - an array of sizes of different smoothings to use for the particle density and pair correlation functions
observablecalc - how many steps between calculating quantities
plotPoints - the number of samples to take in 3D plots; slower to run for large numbers
dimensionality - the dimension of the system
RETURN - an array of plots

plotMaker makes plots of the path, energy, particle density, pair correlation function, and autocorrelation, as requested";
plotMaker::argnum="plotMaker was called with `1` arguments.  It expected 33.";
arrayExtractor::usage="arrayExtractor[energyTherm,energyVirial,energyFullVirial,energyHeinze,calculateParticleDensityX,calculatePairCorrelationFunction,numparticles,arrays]
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
calculateParticleDensityX - whether to calculate the single-particle density
calculatePairCorrelationFunction - whether to calculate the pair/density-density correlation function
numparticles - the number of particles in the system
arrays - an array of arrays of different expectation values
RETURN - an array of expectation values and errors, as {energy(therm),error(therm),energy(virial),error(virial),energy(fullvirial),error(fullvirial),energy(heinze),error(heinze),density,pair corr. fn.,number of successful bisections,number of steps with permutations,the last path,the last joined,the longest permutation cycle}

arrayExtractor takes arrays of expectation values calculated on different processors and combines them into single expectation values per time step";
arrayExtractor::argnum="arrayExtractor was called with `1` arguments.  It expected 8.";
initialisationloop::usage="initialisationloop[showPaths,\[Lambda],\[Tau],slices,numparticles,numsteps,startingRange,startingDelta,dimensionality]
showPaths - whether to plot the starting realisation of particle/bead positions
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
slices - the number of slices/beads per particle
numparticles - the number of particles in the system
numsteps - the total number of time steps used
startingRange - the position range over which to look for local minima to start particles in
startingDelta - the position sampling size over which minima are sought
dimensionality - the dimension of the system
RETURN - an array of the starting particle/bead positions, and starting association of all particles unpermuted

initialisationloop creates the starting particle positions and permutations, also printing some information about the system and the starting positions, if requested";
initialisationloop::argnum="initialisationloop was called with `1` arguments.  It expected 9.";
mainLoop::usage="mainLoop[originalpath,originaljoined,\[Lambda],\[Tau],calculateEnergy,calculateParticleDensity,calculatePairCorrelationFunction,maxcyclelength,dimensionality,numparticles,equilibrationsteps,observablecalc,numsteps,slices,energyTherm,energyVirial,energyFullVirial,energyHeinze,\[Omega],harmonictrap,calculateFracSameWell]
originalpath - an array ofstarting particle/bead positions
originaljoined - an association of starting particle permutations
\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
\[Tau] - the time step, also a measure of inverse temperature
calculateEnergy - whether to calculate the energy expectation value
calculateParticleDensityX - whether to calculate the single-particle density
calculatePairCorrelationFunction - whether to calculate the pair/density-density correlation function
maxcyclelength - the maximum number of particles to attempt to permute labels of in a single move
dimensionality - the dimension of the system
numparticles - the number of particles in the system
equilibrationsteps - number of time steps to equilibrate for before calculating expectation values
observablecalc - how many time steps between calculating expectation values
numsteps - the total number of time steps used
slices - the number of slices/beads per particle
energyTherm - whether to calculate the energy in the thermodynamic approximation
energyVirial - whether to calculate the energy in the virial approximation
energyFullVirial - whether to calculate the energy in the full virial approximation
energyHeinze - whether to calculate the energy using the Heinze procedure
\[Omega] - harmonic trap frequency
harmonictrap - whether to compare to analytic results in an harmonic trap
calculateFracSameWell - whether to calculate fraction of particle pairs in the same well
RETURN - an array of expectation values and other observables

mainLoop does the main body of the path integral monte carlo calculation, calling the bisection algorithm and expectation value creation routines";
mainLoop::argnum="mainLoop was called with `1` arguments.  It expected 21.";
barrierSpacing::usage="barrierSpacing[startingRange,startingDelta,dimensionality,kvec]
startingRange - the position range over which to look for local minima to start particles in
startingDelta - the position sampling size over which minima are sought
dimensionality - the dimension of the system
kvec - a measure of the momentum-space separation between minima of the potential; k in Sin[k x]
RETURN - a plot of the distribution of heights of the barriers between adjacent potential minima

barrierSpacing is used to investigate the distribution of barriers between potential minima, for comparison between potentials";
barrierSpacing::argnum="barrierSpacing was called with `1` arguments.  It expected 4.";
tarjan::usage="tarjan[cycle]
cycle - a 'joined' association of particle permutations
RETURN - an array of the permutation cycle lengths encountered throughout a calculation

tarjan implements a reduced version of the Tarjan algorithm to identify cycles within a permutation association";
tarjan::argnum="tarjan was called with `1` arguments.  It expected 1.";
fracsamewell::usage="fracsamewell[vectorPairCorrelationFunctionsaverarray]
vectorPairCorrelationFunctionsaverarray - an array of pairs of particle positions
RETURN - a real number giving the fraction of pairs within a calculated distance

fracsamewell is used to calculate what proportion of particle pairs are within the same potential minimum";
fracsamewell::argnum="fracsamewell was called with `1` arguments.  It expected 1.";
hoppingt::usage="hoppingt[\[Lambda],kvec,V,a]

\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
kvec - the k in V Sin[k x] for periodic potential
V - the V in V Sin[k x] for periodic potential
a - scattering length
RETURN - a real number, the kinetic energy constant for a Hubbard model

hoppingt is used to calculate the kinetic constant for a Hubbard-model equivalent of a studied lattice";
hoppingt::argnum="hoppingt was called with `1` arguments.  It expected 4.";
barrierU::usage="barrierU[\[Lambda],kvec,V,a]

\[Lambda] - \!\(\*FractionBox[SuperscriptBox[\(\[HBar]\), \(2\)], \(2  m\)]\) for mass of particles m
kvec - the k in V Sin[k x] for periodic potential
V - the V in V Sin[k x] for periodic potential
a - scattering length
RETURN - a real number, the well depth constant for a Hubbard model

barrierU is used to calculate the well depth for a Hubbard-model equivalent of a studied lattice";
barrierU::argnum="barrierU was called with `1` arguments.  It expected 4.";
Begin["`Private`"]
startingPositions[numparticles_,numslices_,samplerange_,sampledelta_,dimensionality_]:=Module[{table,data,heights,minima,position,length},Which[dimensionality==3,table=Table[{x,y,z,extV[{x,y,z}]},{x,-samplerange,samplerange,sampledelta},{y,-samplerange,samplerange,sampledelta},{z,-samplerange,samplerange,sampledelta}];
data=Flatten[table,2];
heights=table[[All,All,All,4]];
minima=SortBy[MaximalBy[Join@@@Partition[Riffle[data[[All,1;;3]],Partition[Flatten[MinDetect[heights],2],{1}]],{2}],Last][[All,1;;3]],extV[#]&];,
dimensionality==2,table=Table[{x,y,extV[{x,y}]},{x,-samplerange,samplerange,sampledelta},{y,-samplerange,samplerange,sampledelta}];
data=Flatten[table,1];
heights=table[[All,All,3]];
minima=SortBy[MaximalBy[Join@@@Partition[Riffle[data[[All,1;;2]],Partition[Flatten[MinDetect[heights],2],{1}]],{2}],Last][[All,1;;2]],extV[#]&];,True,Throw["Unknown dimensionality in startingPositions"]];
length=Length@minima;
Table[minima[[Mod[i,length,1]]],{i,numparticles},{j,numslices}]
];
startingPositions[args___]:=(Message[startingPositions::argnum,Length[{args}]];$Failed)
pathInitialise[numparticles_,numslices_,\[Lambda]_,\[Tau]_,dimensionality_]:=RandomReal[{-Sqrt[2\[Lambda] \[Tau]],Sqrt[2\[Lambda] \[Tau]]},{numparticles,numslices,dimensionality}];
pathInitialise[args___]:=(Message[pathInitialise::argnum,Length[{args}]];$Failed)
vprime[path_,particle_,bead_]:=derivExtV[path[[particle,place[Length@path[[particle]],bead]]]]+Total@Table[derivIntpartV[path[[particle,bead]],path[[place[Length@path,particle+j],bead]]],{j,1,Length@path-1}];
vprime[args___]:=(Message[vprime::argnum,Length[{args}]];$Failed)
springkinetic[post1_,post2_,\[Lambda]_,\[Tau]_]:=Norm[post1-post2]^2/(4\[Lambda] \[Tau]);
springkinetic[args___]:=(Message[springkinetic::argnum,Length[{args}]];$Failed)
springkineticC=Compile[{{post1,_Real,1},{post2,_Real,1},{\[Lambda],_Real},{\[Tau],_Real}},Norm[post1-post2]^2/(4\[Lambda] \[Tau])];
(*springkineticC[args___]:=(Message[springkineticC::argnum,Length[{args}]];$Failed)*)
place[length_,placed_]:=Which[placed>length,placed-length,0<placed<=length,placed,placed<=0,placed+length];
place[args___]:=(Message[place::argnum,Length[{args}]];$Failed)
normalVariate[\[Mu]_,\[Sigma]_,dimensionality_]:=RandomVariate[NormalDistribution[\[Mu],\[Sigma]],dimensionality];
normalVariate[args___]:=(Message[normalVariate::argnum,Length[{args}]];$Failed)
singleBeadDisplace[path_,\[Lambda]_,\[Tau]_,dimensionality_]:=Module[{part,shuffledistance,temppath,temppos,acold,acnew,acceptprob},part=RandomInteger[{1,Length@path}];shuffledistance=RandomInteger[{0,Length@(path[[part]])}];temppath=RotateLeft[#,shuffledistance]&/@path;
temppos=temppath;temppos[[part,2]]+=normalVariate[0,Sqrt[\[Lambda] \[Tau]],dimensionality];
acold=potentialAction1bead[temppath,\[Lambda],\[Tau],part,2]+kineticAction1bead[temppath,\[Lambda],\[Tau],part,2]+kineticAction1bead[temppath,\[Lambda],\[Tau],part,3];
acnew=potentialAction1bead[temppos,\[Lambda],\[Tau],part,2]+kineticAction1bead[temppos,\[Lambda],\[Tau],part,2]+kineticAction1bead[temppos,\[Lambda],\[Tau],part,3];
acceptprob=Exp[-(acnew-acold)](**1 for Bayesian prob of going this way vs the other: needs modifying when change dist*);
If[acceptprob>RandomReal[],{True,temppos},{False,temppath}]];
singleBeadDisplace[args___]:=(Message[singleBeadDisplace::argnum,Length[{args}]];$Failed)
singleElectronDisplace[path_,\[Lambda]_,\[Tau]_,dimensionality_]:=Module[{part,shuffle,temppos,temppost,enold,ennew,acceptprob},part=RandomInteger[{1,Length@path}];shuffle=normalVariate[0,10Sqrt[\[Lambda] \[Tau]],dimensionality];temppost=(#+shuffle)&/@path[[part]];
temppos=ReplacePart[path,part->temppost];enold=Total@Table[potentialAction1bead[path,\[Lambda],\[Tau],part,bead],{bead,Length@path[[part]]}];ennew=Total@Table[potentialAction1bead[temppos,\[Lambda],\[Tau],part,bead],{bead,Length@temppos[[part]]}];acceptprob=Exp[-(ennew-enold)](**1 for Bayesian prob of going this way vs the other: needs modifying when change dist*);
If[acceptprob>RandomReal[],{True,temppos},{False,path}]];
singleElectronDisplace[args___]:=(Message[singleElectronDisplace::argnum,Length[{args}]];$Failed)
bisectionMover[path_,places_?VectorQ,\[Lambda]_,\[Tau]_,dimensionality_]:=(path[[places[[1]]]]+path[[places[[3]]]])/2+normalVariate[0,Sqrt[\[Lambda] \[Tau]],dimensionality];
bisectionMover[args___]:=(Message[bisectionMover::argnum,Length[{args}]];$Failed)
bisectionMoverC=Compile[{{path,_Real,2},{places,_Integer,1},{\[Lambda],_Real},{\[Tau],_Real},{dimensionality,_Integer}},(path[[places[[1]]]]+path[[places[[3]]]])/2+RandomVariate[NormalDistribution[0,Sqrt[\[Lambda] \[Tau]]],dimensionality]];
(*bisectionMoverC[args___]:=(Message[bisectionMoverC::argnum,Length[{args}]];$Failed)*)
bisectionMove[path_,\[Lambda]_,\[Tau]_,dimensionality_]:=Module[{l,part,shuffledistance,temppath,temppos,range,newrange,sets,movedparticles,enold,ennew,acceptprob,complete,rand,probofmove},part=RandomInteger[{1,Length@path}];shuffledistance=RandomInteger[{1,Length@(path[[part]])}];temppath=RotateLeft[#,shuffledistance]&/@path;
l=RandomInteger[{1,Floor@Log2[Length@path[[part]]-1]}];
temppos=temppath;
range=Range[2^l+1];
complete=Catch[Do[If[i==l-1,sets=(#[[{2^0,2^i+1,2^(i+1)+1}]]&/@{range});newrange=Partition[range,2^i+1,2^i],
sets=(#[[{2^0,2^i+1,2^(i+1)+1}]]&/@range);newrange=Flatten[Partition[#,2^i+1,2^i]&/@range,1]];(temppos[[part,#[[2]]]]=bisectionMoverC[temppos[[part]],#,\[Lambda],2^i \[Tau],dimensionality])&/@sets;range=newrange;movedparticles=#[[2]]&/@sets;
enold=Table[potentialAction1bead[temppath,\[Lambda],2^i \[Tau],part,sets[[bead,2]]],{bead,Range@Length@sets}];
ennew=Table[potentialAction1bead[temppos,\[Lambda],2^i \[Tau],part,sets[[bead,2]]],{bead,Range@Length@sets}];
acceptprob=Exp[-(ennew-enold)];
If[AnyTrue[(#<=RandomReal[])&/@(acceptprob),TrueQ],Throw[False]];temppath=temppos;,{i,l-1,0,-1}];True];
(*If[complete,
probofmove=Table[Exp[1/(2\[Lambda] 2^i\[Tau])(Norm[(temppath[[part,sets[[j,1]]]]+temppath[[part,sets[[j,3]]]])/2-temppos[[part,sets[[j,2]]]]]^2-Norm[(temppath[[part,sets[[j,1]]]]+temppath[[part,sets[[j,3]]]])/2-temppath[[part,sets[[j,2]]]]]^2)],{j,Range@Length@sets}];
enold=Table[potentialAction1bead[temppath,\[Lambda],\[Tau],part,bead]+kineticAction1bead[temppath,\[Lambda],\[Tau],part,bead]+kineticAction1bead[temppath,\[Lambda],\[Tau],part,bead+1],{bead,Range[2^l+1]}];
ennew=Table[potentialAction1bead[temppos,\[Lambda],\[Tau],part,bead]+kineticAction1bead[temppos,\[Lambda],\[Tau],part,bead]+kineticAction1bead[temppos,\[Lambda],\[Tau],part,bead+1],{bead,Range[2^l+1]}];acceptprob=Exp[-(ennew-enold)];
acceptprob=acceptprob*probofmove;complete=AllTrue[(#>RandomReal[])&/@acceptprob,TrueQ];];*)
If[complete,{True,temppos},{False,path}]];
bisectionMove[args___]:=(Message[bisectionMove::argnum,Length[{args}]];$Failed)
bisectionMoveStatistics[path_,\[Lambda]_,\[Tau]_,joined_,maxcyclelength_,dimensionality_]:=Module[{beads,l,part,shuffledistance,temppath,temppos,range,newrange,sets,movedparticles,enold,ennew,acceptprob,complete,rand,probofmove,newjoined,cyclelength},part=RandomInteger[{1,Length@path}];
beads=Length@path[[part]];
shuffledistance=RandomInteger[{1,beads}];
temppath=path;
Do[If[j<=shuffledistance,temppath[[joined[i],j-shuffledistance-1]]=path[[i,j]],temppath[[i,j-shuffledistance]]=path[[i,j]]],{i,Length@path},{j,beads}];
cyclelength=RandomInteger[{1,Min[maxcyclelength,Length@path]}];
newjoined=If[cyclelength==1,joined,permutationSampler[temppath,\[Lambda],\[Tau],joined,cyclelength,beads]];
l=RandomInteger[{1,Floor@Log2[beads-1]}];
temppos=temppath;
range=Range[2^l+1];
complete=Catch[Do[If[i==l-1,sets=(#[[{2^0,2^i+1,2^(i+1)+1}]]&/@{range});newrange=Partition[range,2^i+1,2^i],
sets=(#[[{2^0,2^i+1,2^(i+1)+1}]]&/@range);newrange=Flatten[Partition[#,2^i+1,2^i]&/@range,1]];(temppos[[part,#[[2]]]]=bisectionMoverC[temppos[[part]],#,\[Lambda],2^i \[Tau],dimensionality])&/@sets;range=newrange;movedparticles=#[[2]]&/@sets;
enold=Table[potentialAction1beadStatisticsC[temppath,\[Lambda],2^i \[Tau],part,sets[[bead,2]],Values@newjoined],{bead,Range@Length@sets}];
ennew=Table[potentialAction1beadStatisticsC[temppos,\[Lambda],2^i \[Tau],part,sets[[bead,2]],Values@newjoined],{bead,Range@Length@sets}];
acceptprob=Exp[-(ennew-enold)];
If[AnyTrue[(#<=RandomReal[])&/@(acceptprob),TrueQ],Throw[False]];temppath=temppos;,{i,l-1,0,-1}];True];
If[complete,{True,temppos,newjoined},{False,path,joined}]];
bisectionMoveStatistics[args___]:=(Message[bisectionMoveStatistics::argnum,Length[{args}]];$Failed)
permutationSampler[path_,\[Lambda]_,\[Tau]_,joined_,cyclelength_,beads_]:=Module[{places,parts,position,ttransvector,tdirvector,hvector,tempjoined,harr},
places=Range@Length@path;
tempjoined=joined;
parts=Reap[Do[position=places[[RandomInteger[{1,Length@places}]]];Sow[position];places=Delete[places,Position[places,position]];
,{i,Min[Length@path,cyclelength]}]][[2,1]];
(tempjoined[#[[1]]]=joined[#[[2]]])&/@Partition[Join[parts,{parts[[1]]}],2,1];
ttransvector=Map[Exp[-springkineticC[path[[#[[1]],1]],path[[joined[#[[2]]],-1]],\[Lambda],\[Tau] N[beads]]]&,Partition[Join[parts,{parts[[1]]}],2,1]];
tdirvector=Map[Exp[-springkineticC[path[[#[[1]],1]],path[[joined[#[[2]]],-1]],\[Lambda],\[Tau] N[beads]]]&,Map[{#[[1]],#[[2]]}&,Normal@joined][[parts]]];
harr[i_]:=Map[Exp[-springkineticC[path[[i,1]],path[[#,-1]],\[Lambda],\[Tau] N[beads]]]&,Range@Length@path];
hvector=Total/@Map[harr[#]&,parts];
If[RandomReal[]<Total[hvector/tdirvector]/Total[hvector/ttransvector],tempjoined,joined]
];
permutationSampler[args___]:=(Message[permutationSampler::argnum,Length[{args}]];$Failed)
potentialAction1bead[path_,\[Lambda]_,\[Tau]_,particle_,bead_]:=\[Tau]/2 (extV[path[[particle,place[Length@path[[particle]],bead-1]]]]+extV[path[[particle,bead]]])(*\[Tau] extV[path[[particle,bead]]]*)(*\[Tau] NIntegrate[extV[path[[particle,place[Length@path[[particle]],bead-1]]]+(path[[particle,bead]]-path[[particle,place[Length@path[[particle]],bead-1]]])s],{s,0,1},Method\[Rule]{Automatic,"SymbolicProcessing"\[Rule]0}]*)+(*\[Tau]/2(Total@Table[intpartV[path[[particle,place[Length@path[[particle]],bead-1]]],path[[place[Length@path,particle+j],place[Length@path[[particle]],bead-1]]]],{j,1,Length@path-1}]+Total@Table[intpartV[path[[particle,bead]],path[[place[Length@path,particle+j],bead]]],{j,1,Length@path-1}])*)\[Tau] Total@Table[intpartV[path[[particle,bead]],path[[place[Length@path,particle+j],bead]]],{j,1,Length@path-1}];
potentialAction1bead[args___]:=(Message[potentialAction1bead::argnum,Length[{args}]];$Failed)
potentialAction1beadStatistics[path_,\[Lambda]_,\[Tau]_,particle_,bead_,joined_]:=\[Tau]/2 (If[bead==1,extV[path[[joined[particle],Length@path[[joined[particle]]]]]],extV[path[[particle,bead-1]]]]+extV[path[[particle,bead]]])+\[Tau] Total@Table[intpartV[path[[particle,bead]],path[[place[Length@path,particle+j],bead]]],{j,1,Length@path-1}];
potentialAction1beadStatistics[args___]:=(Message[potentialAction1beadStatistics::argnum,Length[{args}]];$Failed)
kineticAction1bead[path_,\[Lambda]_,\[Tau]_,particle_,bead_]:=springkinetic[path[[particle,place[Length@path[[particle]],bead-1]]],path[[particle,place[Length@path[[particle]],bead]]],\[Lambda],\[Tau]];
kineticAction1bead[args___]:=(Message[kineticAction1bead::argnum,Length[{args}]];$Failed)
kineticAction2bead[path_,\[Lambda]_,\[Tau]_,particle_,bead1_,bead2_]:=springkinetic[path[[particle,place[Length@path[[particle]],bead1]]],path[[particle,place[Length@path[[particle]],bead2]]],\[Lambda],\[Tau]];
kineticAction2bead[args___]:=(Message[kineticAction2bead::argnum,Length[{args}]];$Failed)
kineticActionOffset[\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=Which[dimensionality==3,(3 numparticles numslices)/2 Log[4\[Pi] \[Lambda] \[Tau]],dimensionality==2,numparticles numslices Log[2\[Pi] \[Lambda] \[Tau]]];
kineticActionOffset[args___]:=(Message[kineticActionOffset::argnum,Length[{args}]];$Failed)
virialTotalEnergyEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=1/(numslices numparticles) Sum[dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]+1/\[Tau] potentialAction1bead[path,\[Lambda],\[Tau],part,bead],{part,1,numparticles},{bead,1,numslices}];
virialTotalEnergyEstimator[args___]:=(Message[virialTotalEnergyEstimator::argnum,Length[{args}]];$Failed)
virialTotalEnergySquaredEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=1/(numslices numparticles) Sum[(dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]+1/\[Tau] potentialAction1bead[path,\[Lambda],\[Tau],part,bead])^2,{part,1,numparticles},{bead,1,numslices}];
virialTotalEnergySquaredEstimator[args___]:=(Message[virialTotalEnergySquaredEstimator::argnum,Length[{args}]];$Failed)
virialTotalEnergyEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined],{part,1,numparticles},{bead,1,numslices}];
virialTotalEnergyEstimatorStatistics[args___]:=(Message[virialTotalEnergyEstimatorStatistics::argnum,Length[{args}]];$Failed)
virialTotalEnergySquaredEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[(dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined])^2,{part,1,numparticles},{bead,1,numslices}];
virialTotalEnergySquaredEstimatorStatistics[args___]:=(Message[virialTotalEnergySquaredEstimatorStatistics::argnum,Length[{args}]];$Failed)
thermTotalEnergyEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=1/(numslices numparticles) Sum[dimensionality/(2\[Tau])-Norm[path[[part,bead]]-path[[part,place[Length@path[[part]],bead-1]]]]^2/(4\[Lambda] \[Tau]^2)+1/\[Tau] potentialAction1bead[path,\[Lambda],\[Tau],part,bead],{part,1,numparticles},{bead,1,numslices}];
thermTotalEnergyEstimator[args___]:=(Message[thermTotalEnergyEstimator::argnum,Length[{args}]];$Failed)
thermTotalEnergySquaredEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=1/(numslices numparticles) Sum[(dimensionality/(2\[Tau])-Norm[path[[part,bead]]-path[[part,place[Length@path[[part]],bead-1]]]]^2/(4\[Lambda] \[Tau]^2)+1/\[Tau] potentialAction1bead[path,\[Lambda],\[Tau],part,bead])^2,{part,1,numparticles},{bead,1,numslices}];
thermTotalEnergySquaredEstimator[args___]:=(Message[thermTotalEnergySquaredEstimator::argnum,Length[{args}]];$Failed)
thermTotalEnergyEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[dimensionality/(2\[Tau])-Norm[path[[part,bead]]-If[bead==1,path[[joined[part],-1]],path[[part,bead-1]]]]^2/(4\[Lambda] \[Tau]^2)+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined],{part,1,numparticles},{bead,1,numslices}];
thermTotalEnergyEstimatorStatistics[args___]:=(Message[thermTotalEnergyEstimatorStatistics::argnum,Length[{args}]];$Failed)
thermTotalEnergySquaredEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[(dimensionality/(2\[Tau])-Norm[path[[part,bead]]-If[bead==1,path[[joined[part],-1]],path[[part,bead-1]]]]^2/(4\[Lambda] \[Tau]^2)+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined])^2,{part,1,numparticles},{bead,1,numslices}];
thermTotalEnergySquaredEstimatorStatistics[args___]:=(Message[thermTotalEnergySquaredEstimatorStatistics::argnum,Length[{args}]];$Failed)
fullVirialTotalEnergyEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]-1/(4 numparticles numslices \[Tau]^2 \[Lambda]) If[bead==1,(path[[joined[part],-1]]-path[[joined[joined[part]],-1]]).(path[[joined[part],bead]]-path[[joined[joined[part]],-1]]),(path[[part,bead-1]]-path[[joined[part],bead-1]]).(path[[joined[part],bead]]-path[[joined[part],bead-1]])]+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined],{part,1,numparticles},{bead,1,numslices}];
fullVirialTotalEnergyEstimatorStatistics[args___]:=(Message[fullVirialTotalEnergyEstimatorStatistics::argnum,Length[{args}]];$Failed)
fullVirialTotalEnergySquaredEstimatorStatistics[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,joined_,dimensionality_]:=1/(numslices numparticles) Sum[(dimensionality/(2\[Tau] numslices)+1/2 (path[[part,bead]]).vprime[path,part,bead]-1/(4 numparticles  numslices \[Tau]^2 \[Lambda]) If[bead==1,(path[[joined[part],-1]]-path[[joined[joined[part]],-1]]).(path[[joined[part],bead]]-path[[joined[joined[part]],-1]]),(path[[part,bead-1]]-path[[joined[part],bead-1]]).(path[[joined[part],bead]]-path[[joined[part],bead-1]])]+1/\[Tau] potentialAction1beadStatisticsC[path,\[Lambda],\[Tau],part,bead,Values@joined])^2,{part,1,numparticles},{bead,1,numslices}];
fullVirialTotalEnergySquaredEstimatorStatistics[args___]:=(Message[fullVirialTotalEnergySquaredEstimatorStatistics::argnum,Length[{args}]];$Failed)
heinzeTotalEnergyEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=2(heinzeKineticEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]+heinzePotentialEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]);
heinzeTotalEnergyEstimator[args___]:=(Message[heinzeTotalEnergyEstimator::argnum,Length[{args}]];$Failed)
heinzeKineticEnergyEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=Module[{pairDist,particleDist},pairDist=heinzePairDist[path,numparticles,numslices];particleDist=heinzeParticleDist[path,numparticles,numslices];If[numparticles>1,(numparticles-1)/(4Length@pairDist) Sum[pairDist[[i]].derivIntpartV[pairDist[[i]],Which[dimensionality==3,{0,0,0},dimensionality==2,{0,0}]],{i,Length@pairDist}],0]+1/(2Length@particleDist) Sum[particleDist[[i]].derivExtV[particleDist[[i]]],{i,Length@particleDist}]];
heinzeKineticEnergyEstimator[args___]:=(Message[heinzeKineticEnergyEstimator::argnum,Length[{args}]];$Failed)
heinzePotentialEnergyEstimator[path_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,dimensionality_]:=Module[{pairDist,particleDist},pairDist=heinzePairDist[path,numparticles,numslices];particleDist=heinzeParticleDist[path,numparticles,numslices];If[numparticles>1,(numparticles-1)/(2Length@pairDist) Sum[intpartV[pairDist[[i]],Which[dimensionality==3,{0,0,0},dimensionality==2,{0,0}]],{i,Length@pairDist}],0]+1/(2Length@particleDist) Sum[extV[particleDist[[i]]],{i,Length@particleDist}]];
heinzePotentialEnergyEstimator[args___]:=(Message[heinzePotentialEnergyEstimator::argnum,Length[{args}]];$Failed)
heinzePairDist[path_,numparticles_,numslices_]:=(#[[1]]-#[[2]])&/@Join@@(Subsets[#,{2}]&/@(Transpose@path));
heinzePairDist[args___]:=(Message[heinzePairDist::argnum,Length[{args}]];$Failed)
heinzeParticleDist[path_,numparticles_,numslices_]:=Join@@path;
heinzeParticleDist[args___]:=(Message[heinzeParticleDist::argnum,Length[{args}]];$Failed)
potentialPlot[path_,dimensionality_]:=Module[{xmin,xmax,ymin,ymax,zmin,zmax},xmin=MaximalBy[Catenate@path,-#[[1]]&][[1,1]];xmax=MaximalBy[Catenate@path,#[[1]]&][[1,1]];ymin=MaximalBy[Catenate@path,-#[[2]]&][[1,2]];ymax=MaximalBy[Catenate@path,#[[2]]&][[1,2]];If[dimensionality==3,zmin=MaximalBy[Catenate@path,-#[[3]]&][[1,3]];zmax=MaximalBy[Catenate@path,#[[3]]&][[1,3]];];Which[dimensionality==3,SliceDensityPlot3D[extV[{x,y,z}]/extV[{xmax,ymax,zmax}],"BackPlanes",{x,xmin,xmax},{y,ymin,ymax},{z,zmin,zmax},PerformanceGoal->"Speed",ImageSize->Medium,BoundaryStyle->None,BoxRatios->Automatic,AxesLabel->{"x","y","z"}],dimensionality==2,DensityPlot[extV[{x,y}],{x,xmin,xmax},{y,ymin,ymax},(*PerformanceGoal\[Rule]"Speed",*)ImageSize->Medium,BoundaryStyle->None,FrameLabel->{"x","y"},PlotLegends->Automatic,AspectRatio->(ymax-ymin)/(xmax-xmin)]]];
potentialPlot[args___]:=(Message[potentialPlot::argnum,Length[{args}]];$Failed)
energyPlot[energyVirial_,energyFullVirial_,energyTherm_,energyHeinze_,energysaverarrayvirial_,energysaverarrayfullvirial_,energysaverarraytherm_,energysaverarrayheinze_,invvarvirial_,invvarfullvirial_,invvartherm_,invvarheinze_,equilibrationsteps_,numsteps_,harmonictrap_,\[Omega]_,\[Tau]_,slices_,dimensionality_]:=Show[ListPlot[{If[energyVirial,energysaverarrayvirial],If[energyFullVirial,energysaverarrayfullvirial],If[energyTherm,energysaverarraytherm],If[energyHeinze,energysaverarrayheinze]},Joined->True,PlotRange->All,GridLines->{{equilibrationsteps/numsteps},{If[harmonictrap,exactHarmonicTrapEnergies[15,\[Tau],slices,\[Omega],dimensionality],0]}},AxesLabel->{"Fractional step","Energy"},PlotLabel->"Energy per particle",PlotStyle->{Red,Darker@Red,Blue,Darker@Green},PlotLegends->{If[energyVirial,"Virial",""],If[energyFullVirial,"Ceperley Virial",""],If[energyTherm,"Thermodynamic",""],If[energyHeinze,"Heinze",""]},ImageSize->Large],Module[{virialEnergy,virialError,fullVirialEnergy,fullVirialError,thermEnergy,thermError,heinzeEnergy,heinzeError},virialEnergy=If[energyVirial,Total[(energysaverarrayvirial*invvarvirial)[[All,2]]]/Total[(invvarvirial)[[All,2]]],Null];virialError=If[energyVirial, 1/Sqrt@Total[(invvarvirial)[[All,2]]],Null];fullVirialEnergy=If[energyFullVirial,Total[(energysaverarrayfullvirial*invvarfullvirial)[[All,2]]]/Total[(invvarfullvirial)[[All,2]]],Null];fullVirialError=If[energyFullVirial, 1/Sqrt@Total[(invvarfullvirial)[[All,2]]],Null];thermEnergy=If[energyTherm,Total[(energysaverarraytherm*invvartherm)[[All,2]]]/Total[(invvartherm)[[All,2]]],Null];thermError=If[energyTherm, 1/Sqrt@Total[(invvartherm)[[All,2]]],Null];
heinzeEnergy=If[energyHeinze,Mean@energysaverarrayheinze[[All,2]],Null];
heinzeError=If[energyHeinze,StandardDeviation@energysaverarrayheinze[[All,2]]/Sqrt@Length@energysaverarrayheinze[[All,2]],Null];Plot[{virialEnergy,virialEnergy+virialError,virialEnergy- virialError,fullVirialEnergy,fullVirialEnergy+fullVirialError,fullVirialEnergy- fullVirialError,thermEnergy,thermEnergy+thermError,thermEnergy-thermError,heinzeEnergy,heinzeEnergy+heinzeError,heinzeEnergy-heinzeError},{x,equilibrationsteps/numsteps,1},PlotStyle->{If[energyVirial, Red,None],None,None,If[energyFullVirial,Darker@Red,None],None,None,If[energyTherm,Blue,None],None,None,If[energyHeinze,Darker@Green,None],None,None},Filling->{3->{{2},Directive[Lighter@Lighter@Red,Opacity[0.75]]},6->{{5},Directive[Lighter@Red,Opacity[0.75]]},9->{{8},Directive[Lighter@Lighter@Blue,Opacity[0.75]]},12->{{11},Directive[Lighter@Green,Opacity[0.75]]}}]],ListPlot[If[energyTherm,Style@@@Thread[{energysaverarraytherm,(PointSize[0.025Exp[-10/#[[2]]]]&/@invvartherm)}],{}],PlotStyle->Darker@Blue],ListPlot[If[energyVirial,Style@@@Thread[{energysaverarrayvirial,(PointSize[0.025Exp[-10/#[[2]]]]&/@invvarvirial)}],{}],PlotStyle->Darker@Red],ListPlot[If[energyFullVirial,Style@@@Thread[{energysaverarrayfullvirial,(PointSize[0.025Exp[-10/#[[2]]]]&/@invvarfullvirial)}],{}],PlotStyle->Darker@Darker@Red],ListPlot[{If[energyVirial,energysaverarrayvirial],If[energyFullVirial,energysaverarrayfullvirial],If[energyTherm,energysaverarraytherm],If[energyHeinze,energysaverarrayheinze]},Joined->True,PlotRange->All,PlotStyle->{Red,Darker@Red,Blue,Darker@Green},ImageSize->Large]];
energyPlot[args___]:=(Message[energyPlot::argnum,Length[{args}]];$Failed)
pathPlot[path_,joined_,dimensionality_]:=Which[dimensionality==3,Show[ListPointPlot3D[path,PlotStyle->PointSize[0.02],PlotRange->Full,ImageSize->Medium,AxesLabel->{"x","y","z"}],Graphics3D@Line@Transpose@Join[Transpose@path,{path[[joined[#],1]]&/@Range@Length@path}]],dimensionality==2,Show[ListPlot[path,PlotStyle->PointSize[0.02],PlotRange->Full,ImageSize->Medium,AxesLabel->{"x","y","z"}],Graphics@Line@Transpose@Join[Transpose@path,{path[[joined[#],1]]&/@Range@Length@path}]],True,Throw["Unknown dimensionality in pathPlot"]];
pathPlot[args___]:=(Message[pathPlot::argnum,Length[{args}]];$Failed)
printEnergyVirial[energysaverarrayvirial_,invvarvirial_]:=Print["Virial weighted estimator of the energy per particle                : ",Total[(energysaverarrayvirial*invvarvirial)[[All,2]]]/Total[(invvarvirial)[[All,2]]],"+/-", 1/Sqrt@Total[(invvarvirial)[[All,2]]]];
printEnergyVirial[args___]:=(Message[printEnergyVirial::argnum,Length[{args}]];$Failed)
printEnergyFullVirial[energysaverarrayvirial_,invvarvirial_]:=Print["Ceperley virial weighted estimator of the energy per particle       : ",Total[(energysaverarrayvirial*invvarvirial)[[All,2]]]/Total[(invvarvirial)[[All,2]]],"+/-", 1/Sqrt@Total[(invvarvirial)[[All,2]]]];
printEnergyFullVirial[args___]:=(Message[printEnergyFullVirial::argnum,Length[{args}]];$Failed)
printEnergyTherm[energysaverarraytherm_,invvartherm_]:=Print["Thermodynamic weighted estimator of the energy per particle         : ",Total[(energysaverarraytherm*invvartherm)[[All,2]]]/Total[(invvartherm)[[All,2]]],"+/-", 1/Sqrt@Total[(invvartherm)[[All,2]]]];
printEnergyTherm[args___]:=(Message[printEnergyTherm::argnum,Length[{args}]];$Failed)
printEnergyHeinze[energysaverarrayheinze_]:=Print["Heinze (unweighted) estimator of the energy per particle            : ",Mean@energysaverarrayheinze[[All,2]],"+/-",StandardDeviation@energysaverarrayheinze[[All,2]]/Sqrt[Length@energysaverarrayheinze[[All,2]]]];
printEnergyHeinze[args___]:=(Message[printEnergyHeinze::argnum,Length[{args}]];$Failed)
autocorrelationPlot[energyVirial_,energyFullVirial_,energyTherm_,energyHeinze_,energysaverarrayvirial_,energysaverarrayfullvirial_,energysaverarraytherm_,energysaverarrayheinze_,observablecalc_]:=ListLinePlot[{If[energyVirial,Table[{x observablecalc,CorrelationFunction[energysaverarrayvirial[[All,2]],x]},{x,Range[0,Min[10,Length@energysaverarrayvirial-1]]}]],If[energyFullVirial,Table[{x observablecalc,CorrelationFunction[energysaverarrayfullvirial[[All,2]],x]},{x,Range[0,Min[10,Length@energysaverarrayfullvirial-1]]}]],If[energyTherm,Table[{x observablecalc,CorrelationFunction[energysaverarraytherm[[All,2]],x]},{x,Range[0,Min[10,Length@energysaverarraytherm-1]]}]],If[energyHeinze,Table[{x observablecalc,CorrelationFunction[energysaverarrayheinze[[All,2]],x]},{x,Range[0,Min[10,Length@energysaverarrayheinze-1]]}]]},PlotRange->All,PlotStyle->{Red,Darker@Red,Blue,Darker@Green},PlotLegends->{If[energyVirial,"Virial",""],If[energyFullVirial,"Ceperley Virial",""],If[energyTherm,"Thermodynamic",""],If[energyHeinze,"Heinze",""]},PlotLabel->"Autocorrelation in the energy",AxesLabel->{"Step number","Correlation"},ImageSize->Large];
autocorrelationPlot[args___]:=(Message[autocorrelationPlot::argnum,Length[{args}]];$Failed)
exactHarmonicTrapEnergies[maxval_,\[Tau]_,slices_,\[Omega]_,dimensionality_]:=Module[{tableofenergies,tableofoccupations,\[Psi],tableofwfns},tableofenergies=Join@@Table[(n+dimensionality/2)\[Omega],{n,0,maxval},{i,1,Binomial[dimensionality+n-1,n]}];tableofoccupations=Exp[-\[Tau] slices #]&/@tableofenergies;Total@(tableofoccupations*tableofenergies)/Total@tableofoccupations];
exactHarmonicTrapEnergies[args___]:=(Message[exactHarmonicTrapEnergies::argnum,Length[{args}]];$Failed)
exactHarmonicTrapWfns[maxval_,\[Tau]_,slices_,\[Omega]_,dimensionality_]:=Module[{tableofenergies,tableofoccupations,\[Psi],tableofwfns},Which[dimensionality==3,tableofenergies=Join@@Table[(n+dimensionality/2)\[Omega],{n,0,maxval},{i,1,Binomial[dimensionality+n-1,n]}];tableofoccupations=Exp[-\[Tau] slices #]&/@tableofenergies;\[Psi][n_,l_,m_,r_,\[Theta]_,\[Phi]_]:=Sqrt[(2^(n+l+2) \[Omega]^(l+3/2))/\[Pi]^(1/2)]Sqrt[(Factorial[1/2 (n-l)]Factorial[1/2 (n+l)])/Factorial[n+l+1]]r^l Exp[-1/2 \[Omega] r^2]LaguerreL[1/2 (n-l),l+1/2,\[Omega] r^2]SphericalHarmonicY[l,m,\[Theta],\[Phi]];tableofwfns[x_]=1/Total[tableofoccupations] Total[(Flatten@Table[Abs[\[Psi][n,l,m,x,\[Pi]/2,0]]^2,{n,0,maxval},{l,n,0,-2},{m,-l,l}])*tableofoccupations];,dimensionality==2,tableofenergies=Join@@Table[(n+dimensionality/2)\[Omega],{n,0,maxval},{m,n,0,-2}];tableofoccupations=Exp[-\[Tau] slices #]&/@tableofenergies;\[Psi][n_,m_,r_,\[Theta]_]:=Sqrt[\[Omega]^(m+1)]/Sqrt[(((n-m)/2)!)(((n+m)/2)!)\[Pi]] r^m HypergeometricU[(m-n)/2,1+m,r^2]Exp[-1/2 \[Omega] r^2]Exp[I m \[Theta]];tableofwfns[x_]=1/Total[tableofoccupations] Total[(Flatten@Table[Abs[\[Psi][n,m,x,0]]^2,{n,0,maxval},{m,n,0,-2}])*tableofoccupations];];tableofwfns[x]/NIntegrate[tableofwfns[x],{x,-10/Sqrt[\[Omega]],10/Sqrt[\[Omega]]}]];
exactHarmonicTrapWfns[args___]:=(Message[exactHarmonicTrapWfns::argnum,Length[{args}]];$Failed)
energyArrayMaker[energyassoc_?AssociationQ,energysquaredassoc_?AssociationQ]:=Module[{energysavearray,energysquaredsavearray,inversevariancearray},energysavearray=Values@energyassoc(*energyassoc[[Key[#]]]&/@Keys[energyassoc]*);
energysquaredsavearray=Values@energysquaredassoc(*energysquaredassoc[[Key[#]]]&/@Keys[energysquaredassoc]*);
inversevariancearray=({#[[1,1]],1/(#[[2,2]]-#[[1,2]]^2)})&/@Transpose[{energysavearray,energysquaredsavearray}];{energysavearray,inversevariancearray}];
energyArrayMaker[args___]:=(Message[energyArrayMaker::argnum,Length[{args}]];$Failed)
energyAssocMaker[step_,numsteps_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,path_,dimensionality_,type_:"virial"]:=Which[type=="therm",{{step/numsteps,thermTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]},{step/numsteps,thermTotalEnergySquaredEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]}},type=="virial",{{step/numsteps,virialTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]},{step/numsteps,virialTotalEnergySquaredEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]}},type=="heinze",{{step/numsteps,heinzeTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]},{step/numsteps,heinzeTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]^2+numparticles*numslices}}];
energyAssocMaker[args___]:=(Message[energyAssocMaker::argnum,Length[{args}]];$Failed)
energyAssocMakerStatistics[step_,numsteps_,\[Lambda]_,\[Tau]_,numparticles_,numslices_,path_,joined_,dimensionality_,type_:"virial"]:=Which[type=="therm",{{step/numsteps,thermTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]},{step/numsteps,thermTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]}},type=="virial",{{step/numsteps,virialTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]},{step/numsteps,virialTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]}},type=="fullvirial",{{step/numsteps,fullVirialTotalEnergyEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]},{step/numsteps,fullVirialTotalEnergySquaredEstimatorStatistics[path,\[Lambda],\[Tau],numparticles,numslices,joined,dimensionality]}},type=="heinze",{{step/numsteps,heinzeTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]},{step/numsteps,heinzeTotalEnergyEstimator[path,\[Lambda],\[Tau],numparticles,numslices,dimensionality]^2+numparticles*numslices}}];
energyAssocMakerStatistics[args___]:=(Message[energyAssocMakerStatistics::argnum,Length[{args}]];$Failed)
energyMaker[calculateEnergy_,energyTherm_,energyVirial_,energyFullVirial_,energyHeinze_,harmonictrap_,energysaveassoctherm_,energysquaredsaveassoctherm_,energysaveassocvirial_,energysquaredsaveassocvirial_,energysaveassocfullvirial_,energysquaredsaveassocfullvirial_,energysaveassocheinze_,energysquaredsaveassocheinze_,\[Tau]_,slices_,\[Omega]_]:=Module[{energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze},If[calculateEnergy,
If[energyTherm,{energysaverarraytherm,invvartherm}=energyArrayMaker[energysaveassoctherm,energysquaredsaveassoctherm]];
If[energyVirial,{energysaverarrayvirial,invvarvirial}=energyArrayMaker[energysaveassocvirial,energysquaredsaveassocvirial]];
If[energyFullVirial,{energysaverarrayfullvirial,invvarfullvirial}=energyArrayMaker[energysaveassocfullvirial,energysquaredsaveassocfullvirial]];
If[energyHeinze,{energysaverarrayheinze,invvarheinze}=energyArrayMaker[energysaveassocheinze,energysquaredsaveassocheinze]];];
{{energysaverarraytherm,invvartherm},{energysaverarrayvirial,invvarvirial},{energysaverarrayfullvirial,invvarfullvirial},{energysaverarrayheinze,invvarheinze}}
];
energyMaker[args___]:=(Message[energyMaker::argnum,Length[{args}]];$Failed)
energyPrinter[calculateEnergy_,energyTherm_,energyVirial_,energyFullVirial_,energyHeinze_,harmonictrap_,energysaverarraytherm_,invvartherm_,energysaverarrayvirial_,invvarvirial_,energysaverarrayfullvirial_,invvarfullvirial_,energysaverarrayheinze_,invvarheinze_,\[Tau]_,slices_,\[Omega]_,dimensionality_]:=If[calculateEnergy,
If[energyVirial,printEnergyVirial[energysaverarrayvirial,invvarvirial]];If[energyFullVirial,printEnergyFullVirial[energysaverarrayfullvirial,invvarfullvirial]];If[energyTherm,printEnergyTherm[energysaverarraytherm,invvartherm]];If[energyHeinze,printEnergyHeinze[energysaverarrayheinze]];If[harmonictrap,Print["cf numerically exact total energy per non-interacting particle      : ",exactHarmonicTrapEnergies[15,\[Tau],slices,\[Omega],dimensionality]]];
];
energyPrinter[args___]:=(Message[energyPrinter::argnum,Length[{args}]];$Failed)
expectationValueMaker[calculateParticleDensityX_,calculatePairCorrelationFunction_,numparticles_,particleDensityX_,vectorPairCorrelationFunction_]:=Module[{particleDensityXsaverarray,pairCorrelationFunctionsaverarray,vectorPairCorrelationFunctionsaverarray},If[calculateParticleDensityX,particleDensityXsaverarray=Values@particleDensityX];If[calculatePairCorrelationFunction&&numparticles>1,vectorPairCorrelationFunctionsaverarray=Values@vectorPairCorrelationFunction];{particleDensityXsaverarray,vectorPairCorrelationFunctionsaverarray}];
expectationValueMaker[args___]:=(Message[expectationValueMaker::argnum,Length[{args}]];$Failed)
plotMaker[showPaths_,calculateEnergy_,calculateParticleDensityX_,calculatePairCorrelationFunction_,allow3DCorrelationPlots_,showAutocorrelation_,numparticles_,path_,joined_,energyVirial_,energyFullVirial_,energyTherm_,energyHeinze_,energysaverarrayvirial_,energysaverarrayfullvirial_,energysaverarraytherm_,energysaverarrayheinze_,invvarvirial_,invvarfullvirial_,invvartherm_,invvarheinze_,equilibrationsteps_,numsteps_,harmonictrap_,\[Omega]_,\[Tau]_,slices_,particleDensityXsaverarray_,vectorPairCorrelationFunctionsaverarray_,binsize_,observablecalc_,plotPoints_,dimensionality_]:=Module[{pathplot,potentialplot,energyplot,particleDensityXplot,particleDensityXplot3D,pairCorrelationFunctionplot,pairUnweightedCorrelationFunctionplot,autocorrelationplot,plots,xyAveragedPairCorrelationFunctionplot,xPairCorrelationFunctionplot,plotRange,shorterPlotRange,densityPlotRange,partdensfunc,partdenstexture},
PrintTemporary["Currently drawing plots ..."];If[showPaths,pathplot=pathPlot[path,joined,dimensionality];potentialplot=potentialPlot[path,dimensionality]];
If[calculateParticleDensityX&&allow3DCorrelationPlots,densityPlotRange=Sort[Norm[(#)]&/@Join@@particleDensityXsaverarray][[Round[0.95Length[Join@@particleDensityXsaverarray]]]]];
If[calculatePairCorrelationFunction&&numparticles>1,plotRange=Last@Sort[Norm[(#[[1]]-#[[2]])]&/@Join@@vectorPairCorrelationFunctionsaverarray]];
If[calculatePairCorrelationFunction&&numparticles>1,shorterPlotRange=(*plotRange*)Sort[Norm[(#[[1]]-#[[2]])]&/@Join@@vectorPairCorrelationFunctionsaverarray][[Round[0.95Length[Join@@vectorPairCorrelationFunctionsaverarray]]]]];
If[calculateEnergy,energyplot=energyPlot[energyVirial,energyFullVirial,energyTherm,energyHeinze,energysaverarrayvirial,energysaverarrayfullvirial,energysaverarraytherm,energysaverarrayheinze,invvarvirial,invvarfullvirial,invvartherm,invvarheinze,equilibrationsteps,numsteps,harmonictrap,\[Omega],\[Tau],slices,dimensionality]];
If[calculateParticleDensityX,particleDensityXplot=Plot[Evaluate[(PDF[SmoothKernelDistribution[#[[1]]&/@Join@@particleDensityXsaverarray,#,"Cosine"],x]&/@binsize)],{x,First@Sort@(#[[1]]&/@Join@@particleDensityXsaverarray),Last@Sort@(#[[1]]&/@Join@@particleDensityXsaverarray)},PlotStyle->Transpose[{ConstantArray[Orange,Length@binsize],Opacity[1/2^#+1/2]&/@Range@Length@binsize}],Filling->Bottom,FillingStyle->(Opacity[1/2^#]&/@Range@Length@binsize),AxesLabel->{"x position","probability"},PlotLabel->"Particle Density Probability",ImageSize->Large,PlotRange->{Automatic,All}]];If[calculateParticleDensityX&&allow3DCorrelationPlots,Which[dimensionality==3,particleDensityXplot3D=Plot3D[Evaluate[(PDF[SmoothKernelDistribution[#[[1;;2]]&/@Join@@particleDensityXsaverarray,binsize[[1]],"Cosine"],{x,y}])],{x,-densityPlotRange,densityPlotRange},{y,-densityPlotRange,densityPlotRange},PlotRange->All,ImageSize->Large,Mesh->None,PlotPoints->plotPoints,Boxed->False,AxesLabel->{"x","y","probability"},PlotLabel->"2D Particle Density Probability"],dimensionality==2,partdensfunc[x_,y_]=PDF[SmoothKernelDistribution[#[[1;;2]]&/@Join@@particleDensityXsaverarray,binsize[[1]],"Cosine"],{x,y}];
partdenstexture=DensityPlot[extV[{x,y}],{x,-densityPlotRange,densityPlotRange},{y,-densityPlotRange,densityPlotRange},Frame->None,PlotRange->Full,PlotPoints->plotPoints];
particleDensityXplot3D=Show[Plot3D[If[partdensfunc[x,y]<10^-3,Null,partdensfunc[x,y]],{x,-densityPlotRange,densityPlotRange},{y,-densityPlotRange,densityPlotRange},PlotRange->All,ImageSize->Large,Mesh->None,PlotPoints->plotPoints,Boxed->False,AxesLabel->{"x","y","probability"},PlotLabel->"2D Particle Density Probability"],
Graphics3D[{Texture[partdenstexture],Polygon[{{-densityPlotRange,-densityPlotRange,0},{densityPlotRange,-densityPlotRange,0},{densityPlotRange,densityPlotRange,0},{-densityPlotRange,densityPlotRange,0}},VertexTextureCoordinates->{{0,0},{1,0},{1,1},{0,1}}]},Lighting->"Neutral"]]]];
If[calculatePairCorrelationFunction&&numparticles>1,pairCorrelationFunctionplot=Plot[Evaluate[(PDF[SmoothKernelDistribution[Norm[(#[[1]]-#[[2]])]&/@Join@@vectorPairCorrelationFunctionsaverarray,#,"Cosine"],x]&/@binsize)],{x,0,plotRange},PlotStyle->Transpose[{ConstantArray[Orange,Length@binsize],Opacity[1/2^#+1/2]&/@Range@Length@binsize}],Filling->Bottom,FillingStyle->(Opacity[1/2^#]&/@Range@Length@binsize),AxesLabel->{"|r|","probability"},PlotLabel->"Averaged Density-Density Correlation Function",ImageSize->Large]];
If[calculatePairCorrelationFunction&&numparticles>1,pairUnweightedCorrelationFunctionplot=Plot[Evaluate[Which[dimensionality==3,1/x^2,dimensionality==2,1/x](PDF[SmoothKernelDistribution[Norm[(#[[1]]-#[[2]])]&/@Join@@vectorPairCorrelationFunctionsaverarray,#,"Cosine"],x]&/@binsize)],{x,0,plotRange},PlotStyle->Transpose[{ConstantArray[Orange,Length@binsize],Opacity[1/2^#+1/2]&/@Range@Length@binsize}],Filling->Bottom,FillingStyle->(Opacity[1/2^#]&/@Range@Length@binsize),AxesLabel->{"|r|","probability"},PlotLabel->"Pair Correlation Function",ImageSize->Large]];
If[calculatePairCorrelationFunction&&numparticles>1&&allow3DCorrelationPlots,xyAveragedPairCorrelationFunctionplot=Plot3D[Evaluate[PDF[SmoothKernelDistribution[(#[[1]]-#[[2]])[[1;;2]]&/@Join@@vectorPairCorrelationFunctionsaverarray,binsize[[1]],"Cosine"],{x,y}]],{x,-shorterPlotRange,shorterPlotRange},{y,-shorterPlotRange,shorterPlotRange},PlotRange->All,ImageSize->Large,Mesh->None,PlotPoints->plotPoints,Boxed->False,AxesLabel->{"x","y","probability"},PlotLabel->"2D Density-Density Correlation Function"]];
If[calculatePairCorrelationFunction&&numparticles>1&&allow3DCorrelationPlots,xPairCorrelationFunctionplot=Plot3D[Evaluate@PDF[SmoothKernelDistribution[#[[1;;2,1]]&/@Join@@vectorPairCorrelationFunctionsaverarray,binsize[[1]],"Cosine"],{x,y}],{x,-shorterPlotRange,shorterPlotRange},{y,-shorterPlotRange,shorterPlotRange},PlotRange->All,ImageSize->Large,Mesh->None,PlotPoints->plotPoints,Boxed->False,AxesLabel->{"\!\(\*SubscriptBox[\(x\), \(1\)]\)","\!\(\*SubscriptBox[\(x\), \(2\)]\)","probability"},PlotLabel->"x-direction Density-Density Correlation Function"]];
If[showAutocorrelation,autocorrelationplot=autocorrelationPlot[energyVirial,energyFullVirial,energyTherm,energyHeinze,energysaverarrayvirial,energysaverarrayfullvirial,energysaverarraytherm,energysaverarrayheinze,observablecalc]];
plots={};If[showPaths,AppendTo[plots,Show[potentialplot,pathplot]]];If[calculateEnergy,AppendTo[plots,Show[energyplot]]];If[calculateParticleDensityX,AppendTo[plots,If[harmonictrap,Show[{particleDensityXplot,Plot[Evaluate@exactHarmonicTrapWfns[5,\[Tau],slices,\[Omega],dimensionality],{x,-10,10},PlotRange->All]}],Show[particleDensityXplot]]]];If[calculateParticleDensityX&&allow3DCorrelationPlots,AppendTo[plots,Show[particleDensityXplot3D]]];If[calculatePairCorrelationFunction&&numparticles>1,AppendTo[plots,Show[pairCorrelationFunctionplot]]];
If[calculatePairCorrelationFunction&&numparticles>1,AppendTo[plots,Show[pairUnweightedCorrelationFunctionplot]]];
If[calculatePairCorrelationFunction&&numparticles>1&&allow3DCorrelationPlots,AppendTo[plots,Show[xyAveragedPairCorrelationFunctionplot]]];
If[calculatePairCorrelationFunction&&numparticles>1&&allow3DCorrelationPlots,AppendTo[plots,Show[xPairCorrelationFunctionplot]]];If[showAutocorrelation,AppendTo[plots,Show[autocorrelationplot]]];plots];
plotMaker[args___]:=(Message[plotMaker::argnum,Length[{args}]];$Failed)
arrayExtractor[energyTherm_,energyVirial_,energyFullVirial_,energyHeinze_,calculateParticleDensityX_,calculatePairCorrelationFunction_,numparticles_,arrays_]:=Module[{arraysEnergyTherm,arraysInvVarTherm,arraysEnergyVirial,arraysInvVarVirial,arraysEnergyFullVirial,arraysInvVarFullVirial,arraysEnergyHeinze,arraysInvVarHeinze,arraysParticleDensityX,arraysPairCorrelationFunction,numsuccessesBisect,numpermuted,path,joined,longestcycle,arraysVectorPairCorrelationFunction},If[energyTherm,arraysEnergyTherm=Sort/@((Transpose@arrays)[[1]])];If[energyTherm,arraysInvVarTherm=Sort/@((Transpose@arrays)[[2]])];If[energyVirial,arraysEnergyVirial=Sort/@((Transpose@arrays)[[3]])];If[energyVirial,arraysInvVarVirial=Sort/@((Transpose@arrays)[[4]])];If[energyFullVirial,arraysEnergyFullVirial=Sort/@((Transpose@arrays)[[5]])];If[energyFullVirial,arraysInvVarFullVirial=Sort/@((Transpose@arrays)[[6]])];If[energyHeinze,arraysEnergyHeinze=Sort/@((Transpose@arrays)[[7]])];If[energyHeinze,arraysInvVarHeinze=Sort/@((Transpose@arrays)[[8]])];
If[calculateParticleDensityX,arraysParticleDensityX=Sort/@((Transpose@arrays)[[9]])];
If[calculatePairCorrelationFunction&&numparticles>1,arraysVectorPairCorrelationFunction=Sort/@((Transpose@arrays)[[10]])];
numsuccessesBisect=Mean[(Transpose@arrays)[[11]]];
numpermuted=Mean[(Transpose@arrays)[[12]]];
path=(Transpose@arrays)[[13,1]];
joined=(Transpose@arrays)[[14,1]];
longestcycle=(Transpose@arrays)[[15,1]];
{If[energyTherm,Total/@((Transpose@arraysEnergyTherm)*(Transpose@arraysInvVarTherm))/Total/@(Transpose@arraysInvVarTherm)],If[energyTherm,Total/@(Transpose@arraysInvVarTherm)],If[energyVirial,Total/@((Transpose@arraysEnergyVirial)*(Transpose@arraysInvVarVirial))/Total/@(Transpose@arraysInvVarVirial)],If[energyVirial,Total/@(Transpose@arraysInvVarVirial)],If[energyFullVirial,Total/@((Transpose@arraysEnergyFullVirial)*(Transpose@arraysInvVarFullVirial))/Total/@(Transpose@arraysInvVarFullVirial)],If[energyFullVirial,Total/@(Transpose@arraysInvVarFullVirial)],If[energyHeinze,Total/@((Transpose@arraysEnergyHeinze)*(Transpose@arraysInvVarHeinze))/Total/@(Transpose@arraysInvVarHeinze)],If[energyHeinze,Total/@(Transpose@arraysInvVarHeinze)],If[calculateParticleDensityX,Catenate@arraysParticleDensityX],If[calculatePairCorrelationFunction&&numparticles>1,Catenate@arraysVectorPairCorrelationFunction],numsuccessesBisect,numpermuted,path,joined,longestcycle}
];
arrayExtractor[args___]:=(Message[arrayExtractor::argnum,Length[{args}]];$Failed)
initialisationloop[showPaths_,\[Lambda]_,\[Tau]_,slices_,numparticles_,numsteps_,startingRange_,startingDelta_,dimensionality_]:=Module[{originaljoined,originalpath,startingPos},ClearAll[originalpath,originaljoined];PrintTemporary["Currently constructing the starting positions ..."];
originaljoined=Association[];
startingPos=startingPositions[numparticles,slices,startingRange,startingDelta,dimensionality];
If[Length@DeleteDuplicates@Flatten[startingPos,1]<numparticles,Print["Appears to be at least one starting position with more than one particle: check if this is desired behaviour.  If not, try increasing startingRange or decreasing startingDelta."]];
originalpath=startingPos+pathInitialise[numparticles,slices,\[Lambda],\[Tau],dimensionality];Do[originaljoined[i]=i,{i,Length@originalpath}];
Print["Temperature kT=",1/(\[Tau] slices)];
Print["Thermal wavelength \!\(\*SqrtBox[\(2  \[Lambda]\[Tau]\)]\)=",Sqrt[2\[Lambda] \[Tau]]];
potentialAction1beadStatisticsC=ReleaseHold[Hold[Compile[{{path,_Real,3},{\[Lambda]t,_Real},{\[Tau]t,_Real},{particle,_Integer},{bead,_Integer},{joined,_Integer,1}},\[Tau]t/2 (If[bead==1,extV[path[[joined[[particle]],Length@path[[joined[[particle]]]]]]],extV[path[[particle,bead-1]]]]+extV[path[[particle,bead]]])+\[Tau]t Total@Table[intpartV[path[[particle,bead]],path[[place[Length@path,particle+j],bead]]],{j,1,Length@path-1}]]]/.Join@@{DownValues@extV,DownValues@intpartV}];
If[showPaths,PrintTemporary["Currently drawing plot ..."]];
If[showPaths,Print@Show[Which[dimensionality==3,DensityPlot3D[extV[{x,y,z}],{x,-startingRange-Sqrt[2\[Lambda] \[Tau]],startingRange+Sqrt[2\[Lambda] \[Tau]]},{y,-startingRange-Sqrt[2\[Lambda] \[Tau]],startingRange+Sqrt[2\[Lambda] \[Tau]]},{z,-startingRange-Sqrt[2\[Lambda] \[Tau]],startingRange+Sqrt[2\[Lambda] \[Tau]]},OpacityFunction->0.02,PlotLegends->Automatic,AxesLabel->{"x","y","z"}],dimensionality==2,DensityPlot[extV[{x,y}],{x,-startingRange,startingRange},{y,-startingRange,startingRange},FrameLabel->{"x","y"},PlotLegends->Automatic],True,Throw["Unknown dimensionality in initialisationloop"]],pathPlot[originalpath,originaljoined,dimensionality]]];
{originalpath,originaljoined}];
initialisationloop[args___]:=(Message[initialisationloop::argnum,Length[{args}]];$Failed)
mainLoop[originalpath_,originaljoined_,\[Lambda]_,\[Tau]_,calculateEnergy_,calculateParticleDensity_,calculatePairCorrelationFunction_,maxcyclelength_,dimensionality_,numparticles_,equilibrationsteps_,observablecalc_,numsteps_,slices_,energyTherm_,energyVirial_,energyFullVirial_,energyHeinze_,\[Omega]_,harmonictrap_,calculateFracSameWell_,startingRange_]:=Module[{path,joined,particleDensity,energysaveassocvirial,energysaveassocfullvirial,energysaveassoctherm,energysaveassocheinze,energysquaredsaveassocheinze,energysquaredsaveassocvirial,energysquaredsaveassocfullvirial,energysquaredsaveassoctherm,vectorPairCorrelationFunction,numsuccessesBisect,numpermuted,successBisect,kernels,mainRunTime,arrays,energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze,particleDensitysaverarray,vectorPairCorrelationFunctionsaverarray,longestcycle},
CloseKernels[];
path=originalpath;
joined=originaljoined;
longestcycle=0;
particleDensity=Association[];energysaveassocvirial=Association[];energysaveassocfullvirial=Association[];energysaveassoctherm=Association[];energysaveassocheinze=Association[];energysquaredsaveassocheinze=Association[];
energysquaredsaveassocvirial=Association[];energysquaredsaveassocfullvirial=Association[];energysquaredsaveassoctherm=Association[];vectorPairCorrelationFunction=Association[];
If[!(calculateEnergy||calculateParticleDensity||calculatePairCorrelationFunction),Throw["We don't appear to be calculating anything?"]];
If[Length@path[[1]]!=slices,Throw["Double-check you ran the 'Initialisation' cell"]];
LaunchKernels[];
DistributeDefinitions[path,joined,longestcycle,particleDensity,energysaveassocvirial,energysaveassocfullvirial,energysaveassoctherm,energysaveassocheinze,energysquaredsaveassocheinze,energysquaredsaveassocvirial,energysquaredsaveassocfullvirial,energysquaredsaveassoctherm,vectorPairCorrelationFunction,bisectionMoveStatistics,tarjan,energyAssocMakerStatistics,energyMaker,expectationValueMaker];
kernels=ParallelTable[$KernelID->i,{i,$KernelCount}];
SetSharedVariable[kernels];
SetSharedVariable[currentNumber];
currentNumber=ConstantArray[0,Length@kernels];
PrintTemporary["Current fraction complete : ",ProgressIndicator[Dynamic@Mean@currentNumber,{0,100}]];
{mainRunTime,arrays}=AbsoluteTiming[
ParallelEvaluate[numsuccessesBisect=0;numpermuted=0;
successBisect=False;Do[{successBisect,path,joined}=bisectionMoveStatistics[path,\[Lambda],\[Tau],joined,maxcyclelength,dimensionality];If[Length[Union[Normal[joined][[All,2]]]]!=Length[Normal[joined][[All,2]]],Throw["Joined array maps to same particle twice!"]];
If[Normal[joined][[All,2]]!=Range@numparticles&&step>equilibrationsteps,numpermuted++];If[successBisect&&step>equilibrationsteps,numsuccessesBisect++];
If[Divisible[step,observablecalc]&&step>=equilibrationsteps,
If[numparticles>1,If[#>longestcycle,longestcycle=#]&@(First@tarjan[joined])];
If[calculateEnergy,
If[energyTherm,{energysaveassoctherm[step],energysquaredsaveassoctherm[step]}=energyAssocMakerStatistics[step,numsteps,\[Lambda],\[Tau],numparticles,slices,path,joined,dimensionality,"therm"]];
If[energyVirial,{energysaveassocvirial[step],energysquaredsaveassocvirial[step]}=energyAssocMakerStatistics[step,numsteps,\[Lambda],\[Tau],numparticles,slices,path,joined,dimensionality,"virial"]];
If[energyFullVirial,{energysaveassocfullvirial[step],energysquaredsaveassocfullvirial[step]}=energyAssocMakerStatistics[step,numsteps,\[Lambda],\[Tau],numparticles,slices,path,joined,dimensionality,"fullvirial"]];
If[energyHeinze,{energysaveassocheinze[step],energysquaredsaveassocheinze[step]}=energyAssocMakerStatistics[step,numsteps,\[Lambda],\[Tau],numparticles,slices,path,joined,dimensionality,"heinze"]];
If[!(energyTherm||energyVirial||energyFullVirial||energyHeinze),Throw["Calculating energy, but no energy estimators selected!"]];];If[calculateParticleDensity,particleDensity[step]=Join@@path];If[calculatePairCorrelationFunction&&numparticles>1,vectorPairCorrelationFunction[step]=Join@@(Subsets[#,{2}]&/@(Transpose@path))];
];
If[Divisible[step,observablecalc],currentNumber[[$KernelID/.kernels]]=step/numsteps*100.];,{step,numsteps}];
{{energysaverarraytherm,invvartherm},{energysaverarrayvirial,invvarvirial},{energysaverarrayfullvirial,invvarfullvirial},{energysaverarrayheinze,invvarheinze}}=energyMaker[calculateEnergy,energyTherm,energyVirial,energyFullVirial,energyHeinze,harmonictrap,energysaveassoctherm,energysquaredsaveassoctherm,energysaveassocvirial,energysquaredsaveassocvirial,energysaveassocfullvirial,energysquaredsaveassocfullvirial,energysaveassocheinze,energysquaredsaveassocheinze,\[Tau],slices,\[Omega]];
{particleDensitysaverarray,vectorPairCorrelationFunctionsaverarray}=expectationValueMaker[calculateParticleDensity,calculatePairCorrelationFunction,numparticles,particleDensity,vectorPairCorrelationFunction];
{energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze,particleDensitysaverarray,vectorPairCorrelationFunctionsaverarray,numsuccessesBisect,numpermuted,path,joined,longestcycle}]];
Print["Temperature kT=",1/(\[Tau] slices)];
Print["Run time of main loop: ",mainRunTime,"s"];
{energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze,particleDensitysaverarray,vectorPairCorrelationFunctionsaverarray,numsuccessesBisect,numpermuted,path,joined,longestcycle}=arrayExtractor[energyTherm,energyVirial,energyFullVirial,energyHeinze,calculateParticleDensity,calculatePairCorrelationFunction,numparticles,arrays];
Print["Acceptance ratio bisection: ",(numsuccessesBisect+0.)/(numsteps-equilibrationsteps)];
If[numparticles>1,Print["Fractional time with permutations: ",(numpermuted+0.)/(numsteps-equilibrationsteps)]];
If[numparticles>1,Print["Longest permutation cycle: ",longestcycle," which is ",(longestcycle+0.)/numparticles," of all particles"]];
If[numparticles>1&&calculateFracSameWell&&calculatePairCorrelationFunction&&dimensionality==2,Print["Fraction of particle pairs within same well is ",fracsamewell[vectorPairCorrelationFunctionsaverarray,startingRange]]];
{energysaverarraytherm,invvartherm,energysaverarrayvirial,invvarvirial,energysaverarrayfullvirial,invvarfullvirial,energysaverarrayheinze,invvarheinze,particleDensitysaverarray,vectorPairCorrelationFunctionsaverarray,numsuccessesBisect,numpermuted,path,joined}];
mainLoop[args___]:=(Message[mainLoop::argnum,Length[{args}]];$Failed)
barrierSpacing[startingRange_,startingDelta_,dimensionality_,kvec_]:=Module[{table,data,heights,minima,sets},Which[dimensionality==3,Throw["Sorry, this feature isn't implemented for 3D yet"],dimensionality==2,table=ParallelTable[{x,y,extV[{x,y}]},{x,-startingRange,startingRange,startingDelta},{y,-startingRange,startingRange,startingDelta}];
data=Flatten[table,1];
heights=table[[All,All,3]];
minima=SortBy[MaximalBy[Join@@@Partition[Riffle[data[[All,1;;2]],Partition[Flatten[MinDetect[heights],2],{1}]],{2}],Last][[All,1;;2]],extV[#]&];
minima=DeleteDuplicates@Map[{x,y}/.Quiet@FindMinimum[extV[{x,y}],Transpose[{{x,y},#}]][[2]]&,minima];
sets=DeleteCases[Subsets[minima,{2}],x_/;Norm[x[[1]]-x[[2]]]>1.1Sqrt[2]\[Pi]/kvec];Histogram[Flatten@ParallelTable[Map[NMaximize[extV[{x,y}],{x,y}\[Element]Line[#]][[1]]-extV@minima[[i]]&,sets[[Transpose[Position[sets,minima[[i]]]][[1]]]]],{i,Length@minima}],{0.05},AxesLabel->{"|r|","probability"},PlotLabel->"Histogram of barrier heights"],True,Throw["Unknown dimensionality encountered"]]];
barrierSpacing[args___]:=(Message[barrierSpacing::argnum,Length[{args}]];$Failed)
tarjan[cycle_]:=Block[{$RecursionLimit=Max[1024,Length@cycle]},Module[{visited,loops,loopfn,i},visited=ConstantArray[False,Length@cycle];
loops=ConstantArray[0,Length@cycle];
loopfn[loop_,v_]:=If[visited[[v]]==False,
If[cycle[[Key@v]]!=v,visited[[v]]=True;loops[[loop]]++;loopfn[loop,cycle[[Key@v]]],visited[[v]]=True;loops[[loop]]++;]];
For[i=1,i<=Length@cycle,i++,If[visited[[i]]==False,loopfn[i,i];]];
DeleteCases[Reverse@Sort@Flatten@loops,x_/;x==0]
]];
tarjan[args___]:=(Message[tarjan::argnum,Length[{args}]];$Failed)
fracsamewell[vectorPairCorrelationFunctionsaverarray_,startingRange_]:=Module[{firstxmax,joinedlist},firstxmax=x/.FindMaximum[{extV[{x,0}],Abs[x]<startingRange},{x,0.001}][[2]];joinedlist=Join@@vectorPairCorrelationFunctionsaverarray;Count[Norm[(#[[1]]-#[[2]])]&/@joinedlist,x_/;x<firstxmax]/Length@joinedlist//N];
fracsamewell[args___]:=(Message[fracsamewell::argnum,Length[{args}]];$Failed)
hoppingt[\[Lambda]_,kvec_,V_,a_]:=4/Sqrt[\[Pi]] \[Lambda] kvec^2 (V/(\[Lambda] kvec^2))^(3/4) Exp[-2 Sqrt[V/(\[Lambda] kvec^2)]];
hoppingt[args___]:=(Message[hoppingt::argnum,Length[{args}]];$Failed)
barrierU[\[Lambda]_,kvec_,V_,a_]:=Sqrt[8/\[Pi]]kvec a \[Lambda] kvec^2 (V/(\[Lambda] kvec^2))^(3/4);
barrierU[args___]:=(Message[barrierU::argnum,Length[{args}]];$Failed)
End[]
EndPackage[]
